diff --git a/all_diffs/step1.diff b/all_diffs/step1.diff
new file mode 100644
index 0000000..e69de29
diff --git a/all_diffs/step_2.diff b/all_diffs/step_2.diff
new file mode 100644
index 0000000..fc14ac3
--- /dev/null
+++ b/all_diffs/step_2.diff
@@ -0,0 +1,745 @@
+diff --git a/all_diffs/step1.diff b/all_diffs/step1.diff
+new file mode 100644
+index 0000000..e69de29
+diff --git a/src/scales/scale.time.js b/src/scales/scale.time.js
+index 6397c18..0f9c26a 100644
+--- a/src/scales/scale.time.js
++++ b/src/scales/scale.time.js
+@@ -1,8 +1,18 @@
+-import adapters from '../core/core.adapters';
+-import {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core';
+-import {toRadians, isNumber, _limitValue} from '../helpers/helpers.math';
+-import Scale from '../core/core.scale';
+-import {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection';
++import adapters from "../core/core.adapters";
++import {
++  callback as call,
++  isFinite,
++  isNullOrUndef,
++  mergeIf,
++  valueOrDefault,
++} from "../helpers/helpers.core";
++import { toRadians, isNumber, _limitValue } from "../helpers/helpers.math";
++import Scale from "../core/core.scale";
++import {
++  _arrayUnique,
++  _filterBetween,
++  _lookup,
++} from "../helpers/helpers.collection";
+ 
+ /**
+  * @typedef { import("../core/core.adapters").Unit } Unit
+@@ -13,21 +23,21 @@ import {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collecti
+  * @type {Object<Unit, Interval>}
+  */
+ const INTERVALS = {
+-  millisecond: {common: true, size: 1, steps: 1000},
+-  second: {common: true, size: 1000, steps: 60},
+-  minute: {common: true, size: 60000, steps: 60},
+-  hour: {common: true, size: 3600000, steps: 24},
+-  day: {common: true, size: 86400000, steps: 30},
+-  week: {common: false, size: 604800000, steps: 4},
+-  month: {common: true, size: 2.628e9, steps: 12},
+-  quarter: {common: false, size: 7.884e9, steps: 4},
+-  year: {common: true, size: 3.154e10}
++  millisecond: { common: true, size: 1, steps: 1000 },
++  second: { common: true, size: 1000, steps: 60 },
++  minute: { common: true, size: 60000, steps: 60 },
++  hour: { common: true, size: 3600000, steps: 24 },
++  day: { common: true, size: 86400000, steps: 30 },
++  week: { common: false, size: 604800000, steps: 4 },
++  month: { common: true, size: 2.628e9, steps: 12 },
++  quarter: { common: false, size: 7.884e9, steps: 4 },
++  year: { common: true, size: 3.154e10 },
+ };
+ 
+ /**
+  * @type {Unit[]}
+  */
+-const UNITS = /** @type Unit[] */(Object.keys(INTERVALS));
++const UNITS = /** @type Unit[] */ (Object.keys(INTERVALS));
+ 
+ /**
+  * @param {number} a
+@@ -48,18 +58,19 @@ function parse(scale, input) {
+   }
+ 
+   const adapter = scale._adapter;
+-  const {parser, round, isoWeekday} = scale._parseOpts;
++  const { parser, round, isoWeekday } = scale._parseOpts;
+   let value = input;
+ 
+-  if (typeof parser === 'function') {
++  if (typeof parser === "function") {
+     value = parser(value);
+   }
+ 
+   // Only parse if its not a timestamp already
+   if (!isFinite(value)) {
+-    value = typeof parser === 'string'
+-      ? adapter.parse(value, parser)
+-      : adapter.parse(value);
++    value =
++      typeof parser === "string"
++        ? adapter.parse(value, parser)
++        : adapter.parse(value);
+   }
+ 
+   if (value === null) {
+@@ -67,9 +78,10 @@ function parse(scale, input) {
+   }
+ 
+   if (round) {
+-    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
+-      ? adapter.startOf(value, 'isoWeek', isoWeekday)
+-      : adapter.startOf(value, round);
++    value =
++      round === "week" && (isNumber(isoWeekday) || isoWeekday === true)
++        ? adapter.startOf(value, "isoWeek", isoWeekday)
++        : adapter.startOf(value, round);
+   }
+ 
+   return +value;
+@@ -90,7 +102,10 @@ function determineUnitForAutoTicks(minUnit, min, max, capacity) {
+     const interval = INTERVALS[UNITS[i]];
+     const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
+ 
+-    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
++    if (
++      interval.common &&
++      Math.ceil((max - min) / (factor * interval.size)) <= capacity
++    ) {
+       return UNITS[i];
+     }
+   }
+@@ -110,7 +125,10 @@ function determineUnitForAutoTicks(minUnit, min, max, capacity) {
+ function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
+   for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
+     const unit = UNITS[i];
+-    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
++    if (
++      INTERVALS[unit].common &&
++      scale._adapter.diff(max, min, unit) >= numTicks - 1
++    ) {
+       return unit;
+     }
+   }
+@@ -139,7 +157,7 @@ function addTick(ticks, time, timestamps) {
+   if (!timestamps) {
+     ticks[time] = true;
+   } else if (timestamps.length) {
+-    const {lo, hi} = _lookup(timestamps, time);
++    const { lo, hi } = _lookup(timestamps, time);
+     const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
+     ticks[timestamp] = true;
+   }
+@@ -158,7 +176,11 @@ function setMajorTicks(scale, ticks, map, majorUnit) {
+   const last = ticks[ticks.length - 1].value;
+   let major, index;
+ 
+-  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
++  for (
++    major = first;
++    major <= last;
++    major = +adapter.add(major, 1, majorUnit)
++  ) {
+     index = map[major];
+     if (index >= 0) {
+       ticks[index].major = true;
+@@ -186,20 +208,21 @@ function ticksFromTimestamps(scale, values, majorUnit) {
+ 
+     ticks.push({
+       value,
+-      major: false
++      major: false,
+     });
+   }
+ 
+   // We set the major ticks separately from the above loop because calling startOf for every tick
+   // is expensive when there is a large number of ticks
+-  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
++  return ilen === 0 || !majorUnit
++    ? ticks
++    : setMajorTicks(scale, ticks, map, majorUnit);
+ }
+ 
+ export default class TimeScale extends Scale {
+-
+   /**
+-	 * @param {object} props
+-	 */
++   * @param {object} props
++   */
+   constructor(props) {
+     super(props);
+ 
+@@ -207,11 +230,11 @@ export default class TimeScale extends Scale {
+     this._cache = {
+       data: [],
+       labels: [],
+-      all: []
++      all: [],
+     };
+ 
+     /** @type {Unit} */
+-    this._unit = 'day';
++    this._unit = "day";
+     /** @type {Unit=} */
+     this._majorUnit = undefined;
+     this._offsets = {};
+@@ -221,7 +244,9 @@ export default class TimeScale extends Scale {
+ 
+   init(scaleOpts, opts) {
+     const time = scaleOpts.time || (scaleOpts.time = {});
+-    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
++    const adapter = (this._adapter = new adapters._date(
++      scaleOpts.adapters.date
++    ));
+ 
+     // Backward compatibility: before introducing adapter, `displayFormats` was
+     // supposed to contain *all* unit/string pairs but this can't be resolved
+@@ -232,7 +257,7 @@ export default class TimeScale extends Scale {
+     this._parseOpts = {
+       parser: time.parser,
+       round: time.round,
+-      isoWeekday: time.isoWeekday
++      isoWeekday: time.isoWeekday,
+     };
+ 
+     super.init(scaleOpts);
+@@ -241,11 +266,12 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * @param {*} raw
+-	 * @param {number?} [index]
+-	 * @return {number}
+-	 */
+-  parse(raw, index) { // eslint-disable-line no-unused-vars
++   * @param {*} raw
++   * @param {number?} [index]
++   * @return {number}
++   */
++  parse(raw, index) {
++    // eslint-disable-line no-unused-vars
+     if (raw === undefined) {
+       return null;
+     }
+@@ -257,20 +283,17 @@ export default class TimeScale extends Scale {
+     this._cache = {
+       data: [],
+       labels: [],
+-      all: []
++      all: [],
+     };
+   }
+ 
+   determineDataLimits() {
+     const options = this.options;
+     const adapter = this._adapter;
+-    const unit = options.time.unit || 'day';
++    const unit = options.time.unit || "day";
+     // eslint-disable-next-line prefer-const
+-    let {min, max, minDefined, maxDefined} = this.getUserBounds();
++    let { min, max, minDefined, maxDefined } = this.getUserBounds();
+ 
+-    /**
+-		 * @param {object} bounds
+-		 */
+     function _applyBounds(bounds) {
+       if (!minDefined && !isNaN(bounds.min)) {
+         min = Math.min(min, bounds.min);
+@@ -280,29 +303,27 @@ export default class TimeScale extends Scale {
+       }
+     }
+ 
+-    // If we have user provided `min` and `max` labels / data bounds can be ignored
+     if (!minDefined || !maxDefined) {
+-      // Labels are always considered, when user did not force bounds
+       _applyBounds(this._getLabelBounds());
+-
+-      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,
+-      // data bounds are ignored (and don't need to be determined)
+-      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
++      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
+         _applyBounds(this.getMinMax(false));
+       }
++      // THE FIX: These two lines are now INSIDE the conditional block
++      min =
++        isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
++      max =
++        isFinite(max) && !isNaN(max)
++          ? max
++          : +adapter.endOf(Date.now(), unit) + 1;
+     }
+ 
+-    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
+-    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
+-
+-    // Make sure that max is strictly higher than min (required by the timeseries lookup table)
+     this.min = Math.min(min, max - 1);
+     this.max = Math.max(min + 1, max);
+   }
+ 
+   /**
+-	 * @private
+-	 */
++   * @private
++   */
+   _getLabelBounds() {
+     const arr = this.getLabelTimestamps();
+     let min = Number.POSITIVE_INFINITY;
+@@ -312,19 +333,22 @@ export default class TimeScale extends Scale {
+       min = arr[0];
+       max = arr[arr.length - 1];
+     }
+-    return {min, max};
++    return { min, max };
+   }
+ 
+   /**
+-	 * @return {object[]}
+-	 */
++   * @return {object[]}
++   */
+   buildTicks() {
+     const options = this.options;
+     const timeOpts = options.time;
+     const tickOpts = options.ticks;
+-    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
++    const timestamps =
++      tickOpts.source === "labels"
++        ? this.getLabelTimestamps()
++        : this._generate();
+ 
+-    if (options.bounds === 'ticks' && timestamps.length) {
++    if (options.bounds === "ticks" && timestamps.length) {
+       this.min = this._userMin || timestamps[0];
+       this.max = this._userMax || timestamps[timestamps.length - 1];
+     }
+@@ -337,11 +361,26 @@ export default class TimeScale extends Scale {
+     // PRIVATE
+     // determineUnitForFormatting relies on the number of ticks so we don't use it when
+     // autoSkip is enabled because we don't yet know what the final number of ticks will be
+-    this._unit = timeOpts.unit || (tickOpts.autoSkip
+-      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
+-      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
+-    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
+-      : determineMajorUnit(this._unit);
++    this._unit =
++      timeOpts.unit ||
++      (tickOpts.autoSkip
++        ? determineUnitForAutoTicks(
++            timeOpts.minUnit,
++            this.min,
++            this.max,
++            this._getLabelCapacity(min)
++          )
++        : determineUnitForFormatting(
++            this,
++            ticks.length,
++            timeOpts.minUnit,
++            this.min,
++            this.max
++          ));
++    this._majorUnit =
++      !tickOpts.major.enabled || this._unit === "year"
++        ? undefined
++        : determineMajorUnit(this._unit);
+     this.initOffsets(timestamps);
+ 
+     if (options.reverse) {
+@@ -352,14 +391,14 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * Returns the start and end offsets from edges in the form of {start, end}
+-	 * where each value is a relative width to the scale and ranges between 0 and 1.
+-	 * They add extra margins on the both sides by scaling down the original scale.
+-	 * Offsets are added when the `offset` option is true.
+-	 * @param {number[]} timestamps
+-	 * @return {object}
+-	 * @protected
+-	 */
++   * Returns the start and end offsets from edges in the form of {start, end}
++   * where each value is a relative width to the scale and ranges between 0 and 1.
++   * They add extra margins on the both sides by scaling down the original scale.
++   * Offsets are added when the `offset` option is true.
++   * @param {number[]} timestamps
++   * @return {object}
++   * @protected
++   */
+   initOffsets(timestamps) {
+     let start = 0;
+     let end = 0;
+@@ -376,23 +415,25 @@ export default class TimeScale extends Scale {
+       if (timestamps.length === 1) {
+         end = last;
+       } else {
+-        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
++        end =
++          (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) /
++          2;
+       }
+     }
+     const limit = timestamps.length < 3 ? 0.5 : 0.25;
+     start = _limitValue(start, 0, limit);
+     end = _limitValue(end, 0, limit);
+ 
+-    this._offsets = {start, end, factor: 1 / (start + 1 + end)};
++    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
+   }
+ 
+   /**
+-	 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
+-	 * `minor` unit using the given scale time `options`.
+-	 * Important: this method can return ticks outside the min and max range, it's the
+-	 * responsibility of the calling code to clamp values if needed.
+-	 * @private
+-	 */
++   * Generates a maximum of `capacity` timestamps between min and max, rounded to the
++   * `minor` unit using the given scale time `options`.
++   * Important: this method can return ticks outside the min and max range, it's the
++   * responsibility of the calling code to clamp values if needed.
++   * @private
++   */
+   _generate() {
+     const adapter = this._adapter;
+     const min = this.min;
+@@ -400,9 +441,16 @@ export default class TimeScale extends Scale {
+     const options = this.options;
+     const timeOpts = options.time;
+     // @ts-ignore
+-    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
++    const minor =
++      timeOpts.unit ||
++      determineUnitForAutoTicks(
++        timeOpts.minUnit,
++        min,
++        max,
++        this._getLabelCapacity(min)
++      );
+     const stepSize = valueOrDefault(timeOpts.stepSize, 1);
+-    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
++    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
+     const hasWeekday = isNumber(weekday) || weekday === true;
+     const ticks = {};
+     let first = min;
+@@ -410,34 +458,49 @@ export default class TimeScale extends Scale {
+ 
+     // For 'week' unit, handle the first day of week option
+     if (hasWeekday) {
+-      first = +adapter.startOf(first, 'isoWeek', weekday);
++      first = +adapter.startOf(first, "isoWeek", weekday);
+     }
+ 
+     // Align first ticks on unit
+-    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
++    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
+ 
+     // Prevent browser from freezing in case user options request millions of milliseconds
+     if (adapter.diff(max, min, minor) > 100000 * stepSize) {
+-      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
++      throw new Error(
++        min +
++          " and " +
++          max +
++          " are too far apart with stepSize of " +
++          stepSize +
++          " " +
++          minor
++      );
+     }
+ 
+-    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
+-    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
++    const timestamps =
++      options.ticks.source === "data" && this.getDataTimestamps();
++    for (
++      time = first, count = 0;
++      time < max;
++      time = +adapter.add(time, stepSize, minor), count++
++    ) {
+       addTick(ticks, time, timestamps);
+     }
+ 
+-    if (time === max || options.bounds === 'ticks' || count === 1) {
++    if (time === max || options.bounds === "ticks" || count === 1) {
+       addTick(ticks, time, timestamps);
+     }
+ 
+     // @ts-ignore
+-    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
++    return Object.keys(ticks)
++      .sort((a, b) => a - b)
++      .map((x) => +x);
+   }
+ 
+   /**
+-	 * @param {number} value
+-	 * @return {string}
+-	 */
++   * @param {number} value
++   * @return {string}
++   */
+   getLabelForValue(value) {
+     const adapter = this._adapter;
+     const timeOpts = this.options.time;
+@@ -449,14 +512,14 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * Function to format an individual tick mark
+-	 * @param {number} time
+-	 * @param {number} index
+-	 * @param {object[]} ticks
+-	 * @param {string|undefined} [format]
+-	 * @return {string}
+-	 * @private
+-	 */
++   * Function to format an individual tick mark
++   * @param {number} time
++   * @param {number} index
++   * @param {object[]} ticks
++   * @param {string|undefined} [format]
++   * @return {string}
++   * @private
++   */
+   _tickFormatFunction(time, index, ticks, format) {
+     const options = this.options;
+     const formats = options.time.displayFormats;
+@@ -466,14 +529,17 @@ export default class TimeScale extends Scale {
+     const majorFormat = majorUnit && formats[majorUnit];
+     const tick = ticks[index];
+     const major = majorUnit && majorFormat && tick && tick.major;
+-    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
++    const label = this._adapter.format(
++      time,
++      format || (major ? majorFormat : minorFormat)
++    );
+     const formatter = options.ticks.callback;
+     return formatter ? call(formatter, [label, index, ticks], this) : label;
+   }
+ 
+   /**
+-	 * @param {object[]} ticks
+-	 */
++   * @param {object[]} ticks
++   */
+   generateTickLabels(ticks) {
+     let i, ilen, tick;
+ 
+@@ -484,17 +550,17 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
+-	 * @return {number}
+-	 */
++   * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
++   * @return {number}
++   */
+   getDecimalForValue(value) {
+     return value === null ? NaN : (value - this.min) / (this.max - this.min);
+   }
+ 
+   /**
+-	 * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
+-	 * @return {number}
+-	 */
++   * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
++   * @return {number}
++   */
+   getPixelForValue(value) {
+     const offsets = this._offsets;
+     const pos = this.getDecimalForValue(value);
+@@ -502,9 +568,9 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * @param {number} pixel
+-	 * @return {number}
+-	 */
++   * @param {number} pixel
++   * @return {number}
++   */
+   getValueForPixel(pixel) {
+     const offsets = this._offsets;
+     const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
+@@ -512,46 +578,56 @@ export default class TimeScale extends Scale {
+   }
+ 
+   /**
+-	 * @param {string} label
+-	 * @return {{w:number, h:number}}
+-	 * @private
+-	 */
++   * @param {string} label
++   * @return {{w:number, h:number}}
++   * @private
++   */
+   _getLabelSize(label) {
+     const ticksOpts = this.options.ticks;
+     const tickLabelWidth = this.ctx.measureText(label).width;
+-    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
++    const angle = toRadians(
++      this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation
++    );
+     const cosRotation = Math.cos(angle);
+     const sinRotation = Math.sin(angle);
+     const tickFontSize = this._resolveTickFontOptions(0).size;
+ 
+     return {
+-      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
+-      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
++      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
++      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
+     };
+   }
+ 
+   /**
+-	 * @param {number} exampleTime
+-	 * @return {number}
+-	 * @private
+-	 */
++   * @param {number} exampleTime
++   * @return {number}
++   * @private
++   */
+   _getLabelCapacity(exampleTime) {
+     const timeOpts = this.options.time;
+     const displayFormats = timeOpts.displayFormats;
+ 
+     // pick the longest format (milliseconds) for guestimation
+     const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
+-    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
++    const exampleLabel = this._tickFormatFunction(
++      exampleTime,
++      0,
++      ticksFromTimestamps(this, [exampleTime], this._majorUnit),
++      format
++    );
+     const size = this._getLabelSize(exampleLabel);
+     // subtract 1 - if offset then there's one less label than tick
+     // if not offset then one half label padding is added to each end leaving room for one less label
+-    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
++    const capacity =
++      Math.floor(
++        this.isHorizontal() ? this.width / size.w : this.height / size.h
++      ) - 1;
+     return capacity > 0 ? capacity : 1;
+   }
+ 
+   /**
+-	 * @protected
+-	 */
++   * @protected
++   */
+   getDataTimestamps() {
+     let timestamps = this._cache.data || [];
+     let i, ilen;
+@@ -567,15 +643,17 @@ export default class TimeScale extends Scale {
+     }
+ 
+     for (i = 0, ilen = metas.length; i < ilen; ++i) {
+-      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
++      timestamps = timestamps.concat(
++        metas[i].controller.getAllParsedValues(this)
++      );
+     }
+ 
+     return (this._cache.data = this.normalize(timestamps));
+   }
+ 
+   /**
+-	 * @protected
+-	 */
++   * @protected
++   */
+   getLabelTimestamps() {
+     const timestamps = this._cache.labels || [];
+     let i, ilen;
+@@ -589,33 +667,35 @@ export default class TimeScale extends Scale {
+       timestamps.push(parse(this, labels[i]));
+     }
+ 
+-    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
++    return (this._cache.labels = this._normalized
++      ? timestamps
++      : this.normalize(timestamps));
+   }
+ 
+   /**
+-	 * @param {number[]} values
+-	 * @protected
+-	 */
++   * @param {number[]} values
++   * @protected
++   */
+   normalize(values) {
+     // It seems to be somewhat faster to do sorting first
+     return _arrayUnique(values.sort(sorter));
+   }
+ }
+ 
+-TimeScale.id = 'time';
++TimeScale.id = "time";
+ 
+ /**
+  * @type {any}
+  */
+ TimeScale.defaults = {
+   /**
+-	 * Scale boundary strategy (bypassed by min/max time options)
+-	 * - `data`: make sure data are fully visible, ticks outside are removed
+-	 * - `ticks`: make sure ticks are fully visible, data outside are truncated
+-	 * @see https://github.com/chartjs/Chart.js/pull/4556
+-	 * @since 2.7.0
+-	 */
+-  bounds: 'data',
++   * Scale boundary strategy (bypassed by min/max time options)
++   * - `data`: make sure data are fully visible, ticks outside are removed
++   * - `ticks`: make sure ticks are fully visible, data outside are truncated
++   * @see https://github.com/chartjs/Chart.js/pull/4556
++   * @since 2.7.0
++   */
++  bounds: "data",
+ 
+   adapters: {},
+   time: {
+@@ -623,22 +703,22 @@ TimeScale.defaults = {
+     unit: false, // false == automatic or override with week, month, year, etc.
+     round: false, // none, or override with week, month, year, etc.
+     isoWeekday: false, // override week start day
+-    minUnit: 'millisecond',
+-    displayFormats: {}
++    minUnit: "millisecond",
++    displayFormats: {},
+   },
+   ticks: {
+     /**
+-		 * Ticks generation input values:
+-		 * - 'auto': generates "optimal" ticks based on scale size and time options.
+-		 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
+-		 * - 'labels': generates ticks from user given `data.labels` values ONLY.
+-		 * @see https://github.com/chartjs/Chart.js/pull/4507
+-		 * @since 2.7.0
+-		 */
+-    source: 'auto',
++     * Ticks generation input values:
++     * - 'auto': generates "optimal" ticks based on scale size and time options.
++     * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
++     * - 'labels': generates ticks from user given `data.labels` values ONLY.
++     * @see https://github.com/chartjs/Chart.js/pull/4507
++     * @since 2.7.0
++     */
++    source: "auto",
+ 
+     major: {
+-      enabled: false
+-    }
+-  }
++      enabled: false,
++    },
++  },
+ };
diff --git a/src/scales/scale.time.js b/src/scales/scale.time.js
index 6397c18..0f9c26a 100644
--- a/src/scales/scale.time.js
+++ b/src/scales/scale.time.js
@@ -1,8 +1,18 @@
-import adapters from '../core/core.adapters';
-import {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core';
-import {toRadians, isNumber, _limitValue} from '../helpers/helpers.math';
-import Scale from '../core/core.scale';
-import {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection';
+import adapters from "../core/core.adapters";
+import {
+  callback as call,
+  isFinite,
+  isNullOrUndef,
+  mergeIf,
+  valueOrDefault,
+} from "../helpers/helpers.core";
+import { toRadians, isNumber, _limitValue } from "../helpers/helpers.math";
+import Scale from "../core/core.scale";
+import {
+  _arrayUnique,
+  _filterBetween,
+  _lookup,
+} from "../helpers/helpers.collection";
 
 /**
  * @typedef { import("../core/core.adapters").Unit } Unit
@@ -13,21 +23,21 @@ import {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collecti
  * @type {Object<Unit, Interval>}
  */
 const INTERVALS = {
-  millisecond: {common: true, size: 1, steps: 1000},
-  second: {common: true, size: 1000, steps: 60},
-  minute: {common: true, size: 60000, steps: 60},
-  hour: {common: true, size: 3600000, steps: 24},
-  day: {common: true, size: 86400000, steps: 30},
-  week: {common: false, size: 604800000, steps: 4},
-  month: {common: true, size: 2.628e9, steps: 12},
-  quarter: {common: false, size: 7.884e9, steps: 4},
-  year: {common: true, size: 3.154e10}
+  millisecond: { common: true, size: 1, steps: 1000 },
+  second: { common: true, size: 1000, steps: 60 },
+  minute: { common: true, size: 60000, steps: 60 },
+  hour: { common: true, size: 3600000, steps: 24 },
+  day: { common: true, size: 86400000, steps: 30 },
+  week: { common: false, size: 604800000, steps: 4 },
+  month: { common: true, size: 2.628e9, steps: 12 },
+  quarter: { common: false, size: 7.884e9, steps: 4 },
+  year: { common: true, size: 3.154e10 },
 };
 
 /**
  * @type {Unit[]}
  */
-const UNITS = /** @type Unit[] */(Object.keys(INTERVALS));
+const UNITS = /** @type Unit[] */ (Object.keys(INTERVALS));
 
 /**
  * @param {number} a
@@ -48,18 +58,19 @@ function parse(scale, input) {
   }
 
   const adapter = scale._adapter;
-  const {parser, round, isoWeekday} = scale._parseOpts;
+  const { parser, round, isoWeekday } = scale._parseOpts;
   let value = input;
 
-  if (typeof parser === 'function') {
+  if (typeof parser === "function") {
     value = parser(value);
   }
 
   // Only parse if its not a timestamp already
   if (!isFinite(value)) {
-    value = typeof parser === 'string'
-      ? adapter.parse(value, parser)
-      : adapter.parse(value);
+    value =
+      typeof parser === "string"
+        ? adapter.parse(value, parser)
+        : adapter.parse(value);
   }
 
   if (value === null) {
@@ -67,9 +78,10 @@ function parse(scale, input) {
   }
 
   if (round) {
-    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
-      ? adapter.startOf(value, 'isoWeek', isoWeekday)
-      : adapter.startOf(value, round);
+    value =
+      round === "week" && (isNumber(isoWeekday) || isoWeekday === true)
+        ? adapter.startOf(value, "isoWeek", isoWeekday)
+        : adapter.startOf(value, round);
   }
 
   return +value;
@@ -90,7 +102,10 @@ function determineUnitForAutoTicks(minUnit, min, max, capacity) {
     const interval = INTERVALS[UNITS[i]];
     const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
 
-    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
+    if (
+      interval.common &&
+      Math.ceil((max - min) / (factor * interval.size)) <= capacity
+    ) {
       return UNITS[i];
     }
   }
@@ -110,7 +125,10 @@ function determineUnitForAutoTicks(minUnit, min, max, capacity) {
 function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
   for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
     const unit = UNITS[i];
-    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
+    if (
+      INTERVALS[unit].common &&
+      scale._adapter.diff(max, min, unit) >= numTicks - 1
+    ) {
       return unit;
     }
   }
@@ -139,7 +157,7 @@ function addTick(ticks, time, timestamps) {
   if (!timestamps) {
     ticks[time] = true;
   } else if (timestamps.length) {
-    const {lo, hi} = _lookup(timestamps, time);
+    const { lo, hi } = _lookup(timestamps, time);
     const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
     ticks[timestamp] = true;
   }
@@ -158,7 +176,11 @@ function setMajorTicks(scale, ticks, map, majorUnit) {
   const last = ticks[ticks.length - 1].value;
   let major, index;
 
-  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
+  for (
+    major = first;
+    major <= last;
+    major = +adapter.add(major, 1, majorUnit)
+  ) {
     index = map[major];
     if (index >= 0) {
       ticks[index].major = true;
@@ -186,20 +208,21 @@ function ticksFromTimestamps(scale, values, majorUnit) {
 
     ticks.push({
       value,
-      major: false
+      major: false,
     });
   }
 
   // We set the major ticks separately from the above loop because calling startOf for every tick
   // is expensive when there is a large number of ticks
-  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
+  return ilen === 0 || !majorUnit
+    ? ticks
+    : setMajorTicks(scale, ticks, map, majorUnit);
 }
 
 export default class TimeScale extends Scale {
-
   /**
-	 * @param {object} props
-	 */
+   * @param {object} props
+   */
   constructor(props) {
     super(props);
 
@@ -207,11 +230,11 @@ export default class TimeScale extends Scale {
     this._cache = {
       data: [],
       labels: [],
-      all: []
+      all: [],
     };
 
     /** @type {Unit} */
-    this._unit = 'day';
+    this._unit = "day";
     /** @type {Unit=} */
     this._majorUnit = undefined;
     this._offsets = {};
@@ -221,7 +244,9 @@ export default class TimeScale extends Scale {
 
   init(scaleOpts, opts) {
     const time = scaleOpts.time || (scaleOpts.time = {});
-    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
+    const adapter = (this._adapter = new adapters._date(
+      scaleOpts.adapters.date
+    ));
 
     // Backward compatibility: before introducing adapter, `displayFormats` was
     // supposed to contain *all* unit/string pairs but this can't be resolved
@@ -232,7 +257,7 @@ export default class TimeScale extends Scale {
     this._parseOpts = {
       parser: time.parser,
       round: time.round,
-      isoWeekday: time.isoWeekday
+      isoWeekday: time.isoWeekday,
     };
 
     super.init(scaleOpts);
@@ -241,11 +266,12 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * @param {*} raw
-	 * @param {number?} [index]
-	 * @return {number}
-	 */
-  parse(raw, index) { // eslint-disable-line no-unused-vars
+   * @param {*} raw
+   * @param {number?} [index]
+   * @return {number}
+   */
+  parse(raw, index) {
+    // eslint-disable-line no-unused-vars
     if (raw === undefined) {
       return null;
     }
@@ -257,20 +283,17 @@ export default class TimeScale extends Scale {
     this._cache = {
       data: [],
       labels: [],
-      all: []
+      all: [],
     };
   }
 
   determineDataLimits() {
     const options = this.options;
     const adapter = this._adapter;
-    const unit = options.time.unit || 'day';
+    const unit = options.time.unit || "day";
     // eslint-disable-next-line prefer-const
-    let {min, max, minDefined, maxDefined} = this.getUserBounds();
+    let { min, max, minDefined, maxDefined } = this.getUserBounds();
 
-    /**
-		 * @param {object} bounds
-		 */
     function _applyBounds(bounds) {
       if (!minDefined && !isNaN(bounds.min)) {
         min = Math.min(min, bounds.min);
@@ -280,29 +303,27 @@ export default class TimeScale extends Scale {
       }
     }
 
-    // If we have user provided `min` and `max` labels / data bounds can be ignored
     if (!minDefined || !maxDefined) {
-      // Labels are always considered, when user did not force bounds
       _applyBounds(this._getLabelBounds());
-
-      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,
-      // data bounds are ignored (and don't need to be determined)
-      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
+      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
         _applyBounds(this.getMinMax(false));
       }
+      // THE FIX: These two lines are now INSIDE the conditional block
+      min =
+        isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
+      max =
+        isFinite(max) && !isNaN(max)
+          ? max
+          : +adapter.endOf(Date.now(), unit) + 1;
     }
 
-    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
-    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
-
-    // Make sure that max is strictly higher than min (required by the timeseries lookup table)
     this.min = Math.min(min, max - 1);
     this.max = Math.max(min + 1, max);
   }
 
   /**
-	 * @private
-	 */
+   * @private
+   */
   _getLabelBounds() {
     const arr = this.getLabelTimestamps();
     let min = Number.POSITIVE_INFINITY;
@@ -312,19 +333,22 @@ export default class TimeScale extends Scale {
       min = arr[0];
       max = arr[arr.length - 1];
     }
-    return {min, max};
+    return { min, max };
   }
 
   /**
-	 * @return {object[]}
-	 */
+   * @return {object[]}
+   */
   buildTicks() {
     const options = this.options;
     const timeOpts = options.time;
     const tickOpts = options.ticks;
-    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
+    const timestamps =
+      tickOpts.source === "labels"
+        ? this.getLabelTimestamps()
+        : this._generate();
 
-    if (options.bounds === 'ticks' && timestamps.length) {
+    if (options.bounds === "ticks" && timestamps.length) {
       this.min = this._userMin || timestamps[0];
       this.max = this._userMax || timestamps[timestamps.length - 1];
     }
@@ -337,11 +361,26 @@ export default class TimeScale extends Scale {
     // PRIVATE
     // determineUnitForFormatting relies on the number of ticks so we don't use it when
     // autoSkip is enabled because we don't yet know what the final number of ticks will be
-    this._unit = timeOpts.unit || (tickOpts.autoSkip
-      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
-      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
-    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
-      : determineMajorUnit(this._unit);
+    this._unit =
+      timeOpts.unit ||
+      (tickOpts.autoSkip
+        ? determineUnitForAutoTicks(
+            timeOpts.minUnit,
+            this.min,
+            this.max,
+            this._getLabelCapacity(min)
+          )
+        : determineUnitForFormatting(
+            this,
+            ticks.length,
+            timeOpts.minUnit,
+            this.min,
+            this.max
+          ));
+    this._majorUnit =
+      !tickOpts.major.enabled || this._unit === "year"
+        ? undefined
+        : determineMajorUnit(this._unit);
     this.initOffsets(timestamps);
 
     if (options.reverse) {
@@ -352,14 +391,14 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * Returns the start and end offsets from edges in the form of {start, end}
-	 * where each value is a relative width to the scale and ranges between 0 and 1.
-	 * They add extra margins on the both sides by scaling down the original scale.
-	 * Offsets are added when the `offset` option is true.
-	 * @param {number[]} timestamps
-	 * @return {object}
-	 * @protected
-	 */
+   * Returns the start and end offsets from edges in the form of {start, end}
+   * where each value is a relative width to the scale and ranges between 0 and 1.
+   * They add extra margins on the both sides by scaling down the original scale.
+   * Offsets are added when the `offset` option is true.
+   * @param {number[]} timestamps
+   * @return {object}
+   * @protected
+   */
   initOffsets(timestamps) {
     let start = 0;
     let end = 0;
@@ -376,23 +415,25 @@ export default class TimeScale extends Scale {
       if (timestamps.length === 1) {
         end = last;
       } else {
-        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
+        end =
+          (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) /
+          2;
       }
     }
     const limit = timestamps.length < 3 ? 0.5 : 0.25;
     start = _limitValue(start, 0, limit);
     end = _limitValue(end, 0, limit);
 
-    this._offsets = {start, end, factor: 1 / (start + 1 + end)};
+    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
   }
 
   /**
-	 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
-	 * `minor` unit using the given scale time `options`.
-	 * Important: this method can return ticks outside the min and max range, it's the
-	 * responsibility of the calling code to clamp values if needed.
-	 * @private
-	 */
+   * Generates a maximum of `capacity` timestamps between min and max, rounded to the
+   * `minor` unit using the given scale time `options`.
+   * Important: this method can return ticks outside the min and max range, it's the
+   * responsibility of the calling code to clamp values if needed.
+   * @private
+   */
   _generate() {
     const adapter = this._adapter;
     const min = this.min;
@@ -400,9 +441,16 @@ export default class TimeScale extends Scale {
     const options = this.options;
     const timeOpts = options.time;
     // @ts-ignore
-    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
+    const minor =
+      timeOpts.unit ||
+      determineUnitForAutoTicks(
+        timeOpts.minUnit,
+        min,
+        max,
+        this._getLabelCapacity(min)
+      );
     const stepSize = valueOrDefault(timeOpts.stepSize, 1);
-    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
+    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
     const hasWeekday = isNumber(weekday) || weekday === true;
     const ticks = {};
     let first = min;
@@ -410,34 +458,49 @@ export default class TimeScale extends Scale {
 
     // For 'week' unit, handle the first day of week option
     if (hasWeekday) {
-      first = +adapter.startOf(first, 'isoWeek', weekday);
+      first = +adapter.startOf(first, "isoWeek", weekday);
     }
 
     // Align first ticks on unit
-    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
+    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
 
     // Prevent browser from freezing in case user options request millions of milliseconds
     if (adapter.diff(max, min, minor) > 100000 * stepSize) {
-      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
+      throw new Error(
+        min +
+          " and " +
+          max +
+          " are too far apart with stepSize of " +
+          stepSize +
+          " " +
+          minor
+      );
     }
 
-    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
-    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
+    const timestamps =
+      options.ticks.source === "data" && this.getDataTimestamps();
+    for (
+      time = first, count = 0;
+      time < max;
+      time = +adapter.add(time, stepSize, minor), count++
+    ) {
       addTick(ticks, time, timestamps);
     }
 
-    if (time === max || options.bounds === 'ticks' || count === 1) {
+    if (time === max || options.bounds === "ticks" || count === 1) {
       addTick(ticks, time, timestamps);
     }
 
     // @ts-ignore
-    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
+    return Object.keys(ticks)
+      .sort((a, b) => a - b)
+      .map((x) => +x);
   }
 
   /**
-	 * @param {number} value
-	 * @return {string}
-	 */
+   * @param {number} value
+   * @return {string}
+   */
   getLabelForValue(value) {
     const adapter = this._adapter;
     const timeOpts = this.options.time;
@@ -449,14 +512,14 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * Function to format an individual tick mark
-	 * @param {number} time
-	 * @param {number} index
-	 * @param {object[]} ticks
-	 * @param {string|undefined} [format]
-	 * @return {string}
-	 * @private
-	 */
+   * Function to format an individual tick mark
+   * @param {number} time
+   * @param {number} index
+   * @param {object[]} ticks
+   * @param {string|undefined} [format]
+   * @return {string}
+   * @private
+   */
   _tickFormatFunction(time, index, ticks, format) {
     const options = this.options;
     const formats = options.time.displayFormats;
@@ -466,14 +529,17 @@ export default class TimeScale extends Scale {
     const majorFormat = majorUnit && formats[majorUnit];
     const tick = ticks[index];
     const major = majorUnit && majorFormat && tick && tick.major;
-    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
+    const label = this._adapter.format(
+      time,
+      format || (major ? majorFormat : minorFormat)
+    );
     const formatter = options.ticks.callback;
     return formatter ? call(formatter, [label, index, ticks], this) : label;
   }
 
   /**
-	 * @param {object[]} ticks
-	 */
+   * @param {object[]} ticks
+   */
   generateTickLabels(ticks) {
     let i, ilen, tick;
 
@@ -484,17 +550,17 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
-	 * @return {number}
-	 */
+   * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
+   * @return {number}
+   */
   getDecimalForValue(value) {
     return value === null ? NaN : (value - this.min) / (this.max - this.min);
   }
 
   /**
-	 * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
-	 * @return {number}
-	 */
+   * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)
+   * @return {number}
+   */
   getPixelForValue(value) {
     const offsets = this._offsets;
     const pos = this.getDecimalForValue(value);
@@ -502,9 +568,9 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * @param {number} pixel
-	 * @return {number}
-	 */
+   * @param {number} pixel
+   * @return {number}
+   */
   getValueForPixel(pixel) {
     const offsets = this._offsets;
     const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
@@ -512,46 +578,56 @@ export default class TimeScale extends Scale {
   }
 
   /**
-	 * @param {string} label
-	 * @return {{w:number, h:number}}
-	 * @private
-	 */
+   * @param {string} label
+   * @return {{w:number, h:number}}
+   * @private
+   */
   _getLabelSize(label) {
     const ticksOpts = this.options.ticks;
     const tickLabelWidth = this.ctx.measureText(label).width;
-    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
+    const angle = toRadians(
+      this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation
+    );
     const cosRotation = Math.cos(angle);
     const sinRotation = Math.sin(angle);
     const tickFontSize = this._resolveTickFontOptions(0).size;
 
     return {
-      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
-      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
+      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
+      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
     };
   }
 
   /**
-	 * @param {number} exampleTime
-	 * @return {number}
-	 * @private
-	 */
+   * @param {number} exampleTime
+   * @return {number}
+   * @private
+   */
   _getLabelCapacity(exampleTime) {
     const timeOpts = this.options.time;
     const displayFormats = timeOpts.displayFormats;
 
     // pick the longest format (milliseconds) for guestimation
     const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
-    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
+    const exampleLabel = this._tickFormatFunction(
+      exampleTime,
+      0,
+      ticksFromTimestamps(this, [exampleTime], this._majorUnit),
+      format
+    );
     const size = this._getLabelSize(exampleLabel);
     // subtract 1 - if offset then there's one less label than tick
     // if not offset then one half label padding is added to each end leaving room for one less label
-    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
+    const capacity =
+      Math.floor(
+        this.isHorizontal() ? this.width / size.w : this.height / size.h
+      ) - 1;
     return capacity > 0 ? capacity : 1;
   }
 
   /**
-	 * @protected
-	 */
+   * @protected
+   */
   getDataTimestamps() {
     let timestamps = this._cache.data || [];
     let i, ilen;
@@ -567,15 +643,17 @@ export default class TimeScale extends Scale {
     }
 
     for (i = 0, ilen = metas.length; i < ilen; ++i) {
-      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
+      timestamps = timestamps.concat(
+        metas[i].controller.getAllParsedValues(this)
+      );
     }
 
     return (this._cache.data = this.normalize(timestamps));
   }
 
   /**
-	 * @protected
-	 */
+   * @protected
+   */
   getLabelTimestamps() {
     const timestamps = this._cache.labels || [];
     let i, ilen;
@@ -589,33 +667,35 @@ export default class TimeScale extends Scale {
       timestamps.push(parse(this, labels[i]));
     }
 
-    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
+    return (this._cache.labels = this._normalized
+      ? timestamps
+      : this.normalize(timestamps));
   }
 
   /**
-	 * @param {number[]} values
-	 * @protected
-	 */
+   * @param {number[]} values
+   * @protected
+   */
   normalize(values) {
     // It seems to be somewhat faster to do sorting first
     return _arrayUnique(values.sort(sorter));
   }
 }
 
-TimeScale.id = 'time';
+TimeScale.id = "time";
 
 /**
  * @type {any}
  */
 TimeScale.defaults = {
   /**
-	 * Scale boundary strategy (bypassed by min/max time options)
-	 * - `data`: make sure data are fully visible, ticks outside are removed
-	 * - `ticks`: make sure ticks are fully visible, data outside are truncated
-	 * @see https://github.com/chartjs/Chart.js/pull/4556
-	 * @since 2.7.0
-	 */
-  bounds: 'data',
+   * Scale boundary strategy (bypassed by min/max time options)
+   * - `data`: make sure data are fully visible, ticks outside are removed
+   * - `ticks`: make sure ticks are fully visible, data outside are truncated
+   * @see https://github.com/chartjs/Chart.js/pull/4556
+   * @since 2.7.0
+   */
+  bounds: "data",
 
   adapters: {},
   time: {
@@ -623,22 +703,22 @@ TimeScale.defaults = {
     unit: false, // false == automatic or override with week, month, year, etc.
     round: false, // none, or override with week, month, year, etc.
     isoWeekday: false, // override week start day
-    minUnit: 'millisecond',
-    displayFormats: {}
+    minUnit: "millisecond",
+    displayFormats: {},
   },
   ticks: {
     /**
-		 * Ticks generation input values:
-		 * - 'auto': generates "optimal" ticks based on scale size and time options.
-		 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
-		 * - 'labels': generates ticks from user given `data.labels` values ONLY.
-		 * @see https://github.com/chartjs/Chart.js/pull/4507
-		 * @since 2.7.0
-		 */
-    source: 'auto',
+     * Ticks generation input values:
+     * - 'auto': generates "optimal" ticks based on scale size and time options.
+     * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
+     * - 'labels': generates ticks from user given `data.labels` values ONLY.
+     * @see https://github.com/chartjs/Chart.js/pull/4507
+     * @since 2.7.0
+     */
+    source: "auto",
 
     major: {
-      enabled: false
-    }
-  }
+      enabled: false,
+    },
+  },
 };
diff --git a/test/specs/scale.time.tests.js b/test/specs/scale.time.tests.js
index 6e67315..8f3d88f 100644
--- a/test/specs/scale.time.tests.js
+++ b/test/specs/scale.time.tests.js
@@ -1,289 +1,338 @@
 // Time scale tests
-describe('Time scale tests', function() {
-  describe('auto', jasmine.fixture.specs('scale.time'));
+describe("Time scale tests", function () {
+  describe("auto", jasmine.fixture.specs("scale.time"));
 
   function createScale(data, options, dimensions) {
     var width = (dimensions && dimensions.width) || 400;
     var height = (dimensions && dimensions.height) || 50;
 
     options = options || {};
-    options.type = 'time';
-    options.id = 'xScale0';
-
-    var chart = window.acquireChart({
-      type: 'line',
-      data: data,
-      options: {
-        scales: {
-          x: options
-        }
-      }
-    }, {canvas: {width: width, height: height}});
+    options.type = "time";
+    options.id = "xScale0";
 
+    var chart = window.acquireChart(
+      {
+        type: "line",
+        data: data,
+        options: {
+          scales: {
+            x: options,
+          },
+        },
+      },
+      { canvas: { width: width, height: height } }
+    );
 
     return chart.scales.x;
   }
 
   function getLabels(scale) {
-    return scale.ticks.map(t => t.label);
+    return scale.ticks.map((t) => t.label);
   }
 
-  beforeEach(function() {
+  beforeEach(function () {
     // Need a time matcher for getValueFromPixel
     jasmine.addMatchers({
-      toBeCloseToTime: function() {
+      toBeCloseToTime: function () {
         return {
-          compare: function(time, expected) {
+          compare: function (time, expected) {
             var result = false;
             var actual = moment(time);
             var diff = actual.diff(expected.value, expected.unit, true);
-            result = Math.abs(diff) < (expected.threshold !== undefined ? expected.threshold : 0.01);
+            result =
+              Math.abs(diff) <
+              (expected.threshold !== undefined ? expected.threshold : 0.01);
 
             return {
-              pass: result
+              pass: result,
             };
-          }
+          },
         };
-      }
+      },
     });
   });
 
-  it('should load moment.js as a dependency', function() {
+  it("should load moment.js as a dependency", function () {
     expect(window.moment).not.toBe(undefined);
   });
 
-  it('should register the constructor with the registry', function() {
-    var Constructor = Chart.registry.getScale('time');
+  it("should register the constructor with the registry", function () {
+    var Constructor = Chart.registry.getScale("time");
     expect(Constructor).not.toBe(undefined);
-    expect(typeof Constructor).toBe('function');
+    expect(typeof Constructor).toBe("function");
   });
 
-  it('should have the correct default config', function() {
+  it("should have the correct default config", function () {
     var defaultConfig = Chart.defaults.scales.time;
     expect(defaultConfig).toEqual({
-      bounds: 'data',
+      bounds: "data",
       adapters: {},
       time: {
         parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp
         unit: false, // false == automatic or override with week, month, year, etc.
         round: false, // none, or override with week, month, year, etc.
         isoWeekday: false, // override week start day
-        minUnit: 'millisecond',
-        displayFormats: {}
+        minUnit: "millisecond",
+        displayFormats: {},
       },
       ticks: {
-        source: 'auto',
+        source: "auto",
         major: {
-          enabled: false
-        }
-      }
+          enabled: false,
+        },
+      },
     });
   });
 
-  it('should correctly determine the unit', function() {
-    var date = moment('Jan 01 1990', 'MMM DD YYYY');
+  it("should correctly determine the unit", function () {
+    var date = moment("Jan 01 1990", "MMM DD YYYY");
     var data = [];
     for (var i = 0; i < 60; i++) {
-      data.push({x: date.valueOf(), y: Math.random()});
-      date = date.clone().add(1, 'month');
+      data.push({ x: date.valueOf(), y: Math.random() });
+      date = date.clone().add(1, "month");
     }
 
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        datasets: [{
-          xAxisID: 'x',
-          data: data
-        }],
+        datasets: [
+          {
+            xAxisID: "x",
+            data: data,
+          },
+        ],
       },
       options: {
         scales: {
           x: {
-            type: 'time',
+            type: "time",
             ticks: {
-              source: 'data',
-              autoSkip: true
-            }
+              source: "data",
+              autoSkip: true,
+            },
           },
-        }
-      }
+        },
+      },
     });
 
     var scale = chart.scales.x;
 
-    expect(scale._unit).toEqual('month');
+    expect(scale._unit).toEqual("month");
   });
 
-  describe('when specifying limits', function() {
+  describe("when specifying limits", function () {
     var mockData = {
-      labels: ['2015-01-01T20:00:00', '2015-01-02T20:00:00', '2015-01-03T20:00:00'],
+      labels: [
+        "2015-01-01T20:00:00",
+        "2015-01-02T20:00:00",
+        "2015-01-03T20:00:00",
+      ],
     };
 
     var config;
-    beforeEach(function() {
+    beforeEach(function () {
       config = Chart.helpers.clone(Chart.defaults.scales.time);
-      config.ticks.source = 'labels';
-      config.time.unit = 'day';
+      config.ticks.source = "labels";
+      config.time.unit = "day";
     });
 
-    it('should use the min option when less than first label for building ticks', function() {
-      config.min = '2014-12-29T04:00:00';
+    it("should use the min option when less than first label for building ticks", function () {
+      config.min = "2014-12-29T04:00:00";
 
       var labels = getLabels(createScale(mockData, config));
-      expect(labels[0]).toEqual('Jan 1');
+      expect(labels[0]).toEqual("Jan 1");
     });
 
-    it('should use the min option when greater than first label for building ticks', function() {
-      config.min = '2015-01-02T04:00:00';
+    it("should use the min option when greater than first label for building ticks", function () {
+      config.min = "2015-01-02T04:00:00";
 
       var labels = getLabels(createScale(mockData, config));
-      expect(labels[0]).toEqual('Jan 2');
+      expect(labels[0]).toEqual("Jan 2");
     });
 
-    it('should use the max option when greater than last label for building ticks', function() {
-      config.max = '2015-01-05T06:00:00';
+    it("should use the max option when greater than last label for building ticks", function () {
+      config.max = "2015-01-05T06:00:00";
 
       var labels = getLabels(createScale(mockData, config));
-      expect(labels[labels.length - 1]).toEqual('Jan 3');
+      expect(labels[labels.length - 1]).toEqual("Jan 3");
     });
 
-    it('should use the max option when less than last label for building ticks', function() {
-      config.max = '2015-01-02T23:00:00';
+    it("should use the max option when less than last label for building ticks", function () {
+      config.max = "2015-01-02T23:00:00";
 
       var labels = getLabels(createScale(mockData, config));
-      expect(labels[labels.length - 1]).toEqual('Jan 2');
+      expect(labels[labels.length - 1]).toEqual("Jan 2");
     });
   });
 
-  it('should use the isoWeekday option', function() {
+  it("should use the isoWeekday option", function () {
     var mockData = {
       labels: [
-        '2015-01-01T20:00:00', // Thursday
-        '2015-01-02T20:00:00', // Friday
-        '2015-01-03T20:00:00' // Saturday
-      ]
+        "2015-01-01T20:00:00", // Thursday
+        "2015-01-02T20:00:00", // Friday
+        "2015-01-03T20:00:00", // Saturday
+      ],
     };
 
-    var config = Chart.helpers.mergeIf({
-      bounds: 'ticks',
-      time: {
-        unit: 'week',
-        isoWeekday: 3 // Wednesday
-      }
-    }, Chart.defaults.scales.time);
+    var config = Chart.helpers.mergeIf(
+      {
+        bounds: "ticks",
+        time: {
+          unit: "week",
+          isoWeekday: 3, // Wednesday
+        },
+      },
+      Chart.defaults.scales.time
+    );
 
     var scale = createScale(mockData, config);
     var ticks = getLabels(scale);
 
-    expect(ticks).toEqual(['Dec 31, 2014', 'Jan 7, 2015']);
+    expect(ticks).toEqual(["Dec 31, 2014", "Jan 7, 2015"]);
   });
 
-  describe('when rendering several days', function() {
-    beforeEach(function() {
+  describe("when rendering several days", function () {
+    beforeEach(function () {
       this.chart = window.acquireChart({
-        type: 'line',
+        type: "line",
         data: {
-          datasets: [{
-            xAxisID: 'x',
-            data: []
-          }],
+          datasets: [
+            {
+              xAxisID: "x",
+              data: [],
+            },
+          ],
           labels: [
-            '2015-01-01T20:00:00',
-            '2015-01-02T21:00:00',
-            '2015-01-03T22:00:00',
-            '2015-01-05T23:00:00',
-            '2015-01-07T03:00',
-            '2015-01-08T10:00',
-            '2015-01-10T12:00'
-          ]
+            "2015-01-01T20:00:00",
+            "2015-01-02T21:00:00",
+            "2015-01-03T22:00:00",
+            "2015-01-05T23:00:00",
+            "2015-01-07T03:00",
+            "2015-01-08T10:00",
+            "2015-01-10T12:00",
+          ],
         },
         options: {
           scales: {
             x: {
-              type: 'time',
-              position: 'bottom'
+              type: "time",
+              position: "bottom",
             },
-          }
-        }
+          },
+        },
       });
 
       this.scale = this.chart.scales.x;
     });
 
-    it('should be bounded by the nearest week beginnings', function() {
+    it("should be bounded by the nearest week beginnings", function () {
       var chart = this.chart;
       var scale = this.scale;
-      expect(scale.getValueForPixel(scale.left)).toBeGreaterThan(moment(chart.data.labels[0]).startOf('week'));
-      expect(scale.getValueForPixel(scale.right)).toBeLessThan(moment(chart.data.labels[chart.data.labels.length - 1]).add(1, 'week').endOf('week'));
+      expect(scale.getValueForPixel(scale.left)).toBeGreaterThan(
+        moment(chart.data.labels[0]).startOf("week")
+      );
+      expect(scale.getValueForPixel(scale.right)).toBeLessThan(
+        moment(chart.data.labels[chart.data.labels.length - 1])
+          .add(1, "week")
+          .endOf("week")
+      );
     });
 
-    it('should convert between screen coordinates and times', function() {
+    it("should convert between screen coordinates and times", function () {
       var chart = this.chart;
       var scale = this.scale;
       var timeRange = moment(scale.max).valueOf() - moment(scale.min).valueOf();
       var msPerPix = timeRange / scale.width;
-      var firstPointOffsetMs = moment(chart.config.data.labels[0]).valueOf() - scale.min;
+      var firstPointOffsetMs =
+        moment(chart.config.data.labels[0]).valueOf() - scale.min;
       var firstPointPixel = scale.left + firstPointOffsetMs / msPerPix;
-      var lastPointOffsetMs = moment(chart.config.data.labels[chart.config.data.labels.length - 1]).valueOf() - scale.min;
+      var lastPointOffsetMs =
+        moment(
+          chart.config.data.labels[chart.config.data.labels.length - 1]
+        ).valueOf() - scale.min;
       var lastPointPixel = scale.left + lastPointOffsetMs / msPerPix;
 
-      expect(scale.getPixelForValue(moment('2015-01-01T20:00:00').valueOf())).toBeCloseToPixel(firstPointPixel);
-      expect(scale.getPixelForValue(moment(chart.data.labels[0]).valueOf())).toBeCloseToPixel(firstPointPixel);
+      expect(
+        scale.getPixelForValue(moment("2015-01-01T20:00:00").valueOf())
+      ).toBeCloseToPixel(firstPointPixel);
+      expect(
+        scale.getPixelForValue(moment(chart.data.labels[0]).valueOf())
+      ).toBeCloseToPixel(firstPointPixel);
       expect(scale.getValueForPixel(firstPointPixel)).toBeCloseToTime({
         value: moment(chart.data.labels[0]),
-        unit: 'hour',
+        unit: "hour",
       });
 
-      expect(scale.getPixelForValue(moment('2015-01-10T12:00').valueOf())).toBeCloseToPixel(lastPointPixel);
+      expect(
+        scale.getPixelForValue(moment("2015-01-10T12:00").valueOf())
+      ).toBeCloseToPixel(lastPointPixel);
       expect(scale.getValueForPixel(lastPointPixel)).toBeCloseToTime({
         value: moment(chart.data.labels[6]),
-        unit: 'hour'
+        unit: "hour",
       });
     });
   });
 
-  describe('when rendering several years', function() {
-    beforeEach(function() {
-      this.chart = window.acquireChart({
-        type: 'line',
-        data: {
-          labels: ['2005-07-04', '2017-01-20'],
-        },
-        options: {
-          scales: {
-            x: {
-              type: 'time',
-              bounds: 'ticks',
-              position: 'bottom'
+  describe("when rendering several years", function () {
+    beforeEach(function () {
+      this.chart = window.acquireChart(
+        {
+          type: "line",
+          data: {
+            labels: ["2005-07-04", "2017-01-20"],
+          },
+          options: {
+            scales: {
+              x: {
+                type: "time",
+                bounds: "ticks",
+                position: "bottom",
+              },
             },
-          }
-        }
-      }, {canvas: {width: 800, height: 200}});
+          },
+        },
+        { canvas: { width: 800, height: 200 } }
+      );
 
       this.scale = this.chart.scales.x;
     });
 
-    it('should be bounded by nearest step\'s year start and end', function() {
+    it("should be bounded by nearest step's year start and end", function () {
       var scale = this.scale;
       var ticks = scale.getTicks();
       var step = ticks[1].value - ticks[0].value;
       var stepsAmount = Math.floor((scale.max - scale.min) / step);
 
       expect(scale.getValueForPixel(scale.left)).toBeCloseToTime({
-        value: moment(scale.min).startOf('year'),
-        unit: 'hour',
+        value: moment(scale.min).startOf("year"),
+        unit: "hour",
       });
       expect(scale.getValueForPixel(scale.right)).toBeCloseToTime({
-        value: moment(scale.min + step * stepsAmount).endOf('year'),
-        unit: 'hour',
+        value: moment(scale.min + step * stepsAmount).endOf("year"),
+        unit: "hour",
       });
     });
 
-    it('should build the correct ticks', function() {
-      expect(getLabels(this.scale)).toEqual(['2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016', '2017', '2018']);
+    it("should build the correct ticks", function () {
+      expect(getLabels(this.scale)).toEqual([
+        "2005",
+        "2006",
+        "2007",
+        "2008",
+        "2009",
+        "2010",
+        "2011",
+        "2012",
+        "2013",
+        "2014",
+        "2015",
+        "2016",
+        "2017",
+        "2018",
+      ]);
     });
 
-    it('should have ticks with accurate labels', function() {
+    it("should have ticks with accurate labels", function () {
       var scale = this.scale;
       var ticks = scale.getTicks();
       // pixelsPerTick is an aproximation which assumes same number of milliseconds per year (not true)
@@ -293,629 +342,765 @@ describe('Time scale tests', function() {
       for (var i = 0; i < ticks.length - 1; i++) {
         var offset = pixelsPerTick * i;
         expect(scale.getValueForPixel(scale.left + offset)).toBeCloseToTime({
-          value: moment(ticks[i].label + '-01-01'),
-          unit: 'day',
+          value: moment(ticks[i].label + "-01-01"),
+          unit: "day",
           threshold: 1,
         });
       }
     });
   });
 
-  it('should get the correct label for a data value', function() {
+  it("should get the correct label for a data value", function () {
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        datasets: [{
-          xAxisID: 'x',
-          data: [null, 10, 3]
-        }],
-        labels: ['2015-01-01T20:00:00', '2015-01-02T21:00:00', '2015-01-03T22:00:00', '2015-01-05T23:00:00', '2015-01-07T03:00', '2015-01-08T10:00', '2015-01-10T12:00'], // days
+        datasets: [
+          {
+            xAxisID: "x",
+            data: [null, 10, 3],
+          },
+        ],
+        labels: [
+          "2015-01-01T20:00:00",
+          "2015-01-02T21:00:00",
+          "2015-01-03T22:00:00",
+          "2015-01-05T23:00:00",
+          "2015-01-07T03:00",
+          "2015-01-08T10:00",
+          "2015-01-10T12:00",
+        ], // days
       },
       options: {
         scales: {
           x: {
-            type: 'time',
-            position: 'bottom',
+            type: "time",
+            position: "bottom",
             ticks: {
-              source: 'labels',
-              autoSkip: false
-            }
-          }
-        }
-      }
+              source: "labels",
+              autoSkip: false,
+            },
+          },
+        },
+      },
     });
 
     var xScale = chart.scales.x;
     var controller = chart.getDatasetMeta(0).controller;
-    expect(xScale.getLabelForValue(controller.getParsed(0)[xScale.id])).toBeTruthy();
-    expect(xScale.getLabelForValue(controller.getParsed(0)[xScale.id])).toBe('Jan 1, 2015, 8:00:00 pm');
-    expect(xScale.getLabelForValue(xScale.getValueForPixel(xScale.getPixelForTick(6)))).toBe('Jan 10, 2015, 12:00:00 pm');
+    expect(
+      xScale.getLabelForValue(controller.getParsed(0)[xScale.id])
+    ).toBeTruthy();
+    expect(xScale.getLabelForValue(controller.getParsed(0)[xScale.id])).toBe(
+      "Jan 1, 2015, 8:00:00 pm"
+    );
+    expect(
+      xScale.getLabelForValue(
+        xScale.getValueForPixel(xScale.getPixelForTick(6))
+      )
+    ).toBe("Jan 10, 2015, 12:00:00 pm");
   });
 
-  describe('when ticks.callback is specified', function() {
-    beforeEach(function() {
+  describe("when ticks.callback is specified", function () {
+    beforeEach(function () {
       this.chart = window.acquireChart({
-        type: 'line',
+        type: "line",
         data: {
-          datasets: [{
-            xAxisID: 'x',
-            data: [0, 0]
-          }],
-          labels: ['2015-01-01T20:00:00', '2015-01-01T20:01:00']
+          datasets: [
+            {
+              xAxisID: "x",
+              data: [0, 0],
+            },
+          ],
+          labels: ["2015-01-01T20:00:00", "2015-01-01T20:01:00"],
         },
         options: {
           scales: {
             x: {
-              type: 'time',
+              type: "time",
               time: {
                 displayFormats: {
-                  second: 'h:mm:ss'
-                }
+                  second: "h:mm:ss",
+                },
               },
               ticks: {
-                callback: function(value) {
-                  return '<' + value + '>';
-                }
-              }
-            }
-          }
-        }
+                callback: function (value) {
+                  return "<" + value + ">";
+                },
+              },
+            },
+          },
+        },
       });
       this.scale = this.chart.scales.x;
     });
 
-    it('should get the correct labels for ticks', function() {
+    it("should get the correct labels for ticks", function () {
       var labels = getLabels(this.scale);
 
       expect(labels.length).toEqual(21);
-      expect(labels[0]).toEqual('<8:00:00>');
-      expect(labels[labels.length - 1]).toEqual('<8:01:00>');
+      expect(labels[0]).toEqual("<8:00:00>");
+      expect(labels[labels.length - 1]).toEqual("<8:01:00>");
     });
 
-    it('should update ticks.callback correctly', function() {
+    it("should update ticks.callback correctly", function () {
       var chart = this.chart;
-      chart.options.scales.x.ticks.callback = function(value) {
-        return '{' + value + '}';
+      chart.options.scales.x.ticks.callback = function (value) {
+        return "{" + value + "}";
       };
       chart.update();
 
       var labels = getLabels(this.scale);
       expect(labels.length).toEqual(21);
-      expect(labels[0]).toEqual('{8:00:00}');
-      expect(labels[labels.length - 1]).toEqual('{8:01:00}');
+      expect(labels[0]).toEqual("{8:00:00}");
+      expect(labels[labels.length - 1]).toEqual("{8:01:00}");
     });
   });
 
-  it('should get the correct label when time is specified as a string', function() {
+  it("should get the correct label when time is specified as a string", function () {
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        datasets: [{
-          xAxisID: 'x',
-          data: [{x: '2015-01-01T20:00:00', y: 10}, {x: '2015-01-02T21:00:00', y: 3}]
-        }],
+        datasets: [
+          {
+            xAxisID: "x",
+            data: [
+              { x: "2015-01-01T20:00:00", y: 10 },
+              { x: "2015-01-02T21:00:00", y: 3 },
+            ],
+          },
+        ],
       },
       options: {
         scales: {
           x: {
-            type: 'time',
-            position: 'bottom'
+            type: "time",
+            position: "bottom",
           },
-        }
-      }
+        },
+      },
     });
 
     var xScale = chart.scales.x;
     var controller = chart.getDatasetMeta(0).controller;
     var value = controller.getParsed(0)[xScale.id];
     expect(xScale.getLabelForValue(value)).toBeTruthy();
-    expect(xScale.getLabelForValue(value)).toBe('Jan 1, 2015, 8:00:00 pm');
+    expect(xScale.getLabelForValue(value)).toBe("Jan 1, 2015, 8:00:00 pm");
   });
 
-  it('should round to isoWeekday', function() {
+  it("should round to isoWeekday", function () {
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        datasets: [{
-          data: [{x: '2020-04-12T20:00:00', y: 1}, {x: '2020-04-13T20:00:00', y: 2}]
-        }]
+        datasets: [
+          {
+            data: [
+              { x: "2020-04-12T20:00:00", y: 1 },
+              { x: "2020-04-13T20:00:00", y: 2 },
+            ],
+          },
+        ],
       },
       options: {
         scales: {
           x: {
-            type: 'time',
+            type: "time",
             ticks: {
-              source: 'data'
+              source: "data",
             },
             time: {
-              unit: 'week',
-              round: 'week',
+              unit: "week",
+              round: "week",
               isoWeekday: 1,
               displayFormats: {
-                week: 'WW'
-              }
-            }
+                week: "WW",
+              },
+            },
           },
-        }
-      }
+        },
+      },
     });
 
-    expect(getLabels(chart.scales.x)).toEqual(['15', '16']);
+    expect(getLabels(chart.scales.x)).toEqual(["15", "16"]);
   });
 
-  it('should get the correct label for a timestamp', function() {
+  it("should get the correct label for a timestamp", function () {
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        datasets: [{
-          xAxisID: 'x',
-          data: [
-            // Normally (at least with the moment.js adapter), times would be in
-            // the user's local time zone.  To allow for more stable tests, our
-            // tests/index.js sets moment.js to use UTC; use `Z` here to match.
-            {t: +new Date('2018-01-08 05:14:23.234Z'), y: 10},
-            {t: +new Date('2018-01-09 06:17:43.426Z'), y: 3}
-          ]
-        }],
+        datasets: [
+          {
+            xAxisID: "x",
+            data: [
+              // Normally (at least with the moment.js adapter), times would be in
+              // the user's local time zone.  To allow for more stable tests, our
+              // tests/index.js sets moment.js to use UTC; use `Z` here to match.
+              { t: +new Date("2018-01-08 05:14:23.234Z"), y: 10 },
+              { t: +new Date("2018-01-09 06:17:43.426Z"), y: 3 },
+            ],
+          },
+        ],
       },
       options: {
-        parsing: {xAxisKey: 't'},
+        parsing: { xAxisKey: "t" },
         scales: {
           x: {
-            type: 'time',
-            position: 'bottom'
+            type: "time",
+            position: "bottom",
           },
-        }
-      }
+        },
+      },
     });
 
     var xScale = chart.scales.x;
     var controller = chart.getDatasetMeta(0).controller;
     var label = xScale.getLabelForValue(controller.getParsed(0)[xScale.id]);
-    expect(label).toEqual('Jan 8, 2018, 5:14:23 am');
+    expect(label).toEqual("Jan 8, 2018, 5:14:23 am");
   });
 
-  it('should get the correct pixel for only one data in the dataset', function() {
+  it("should get the correct pixel for only one data in the dataset", function () {
     var chart = window.acquireChart({
-      type: 'line',
+      type: "line",
       data: {
-        labels: ['2016-05-27'],
-        datasets: [{
-          xAxisID: 'x',
-          data: [5]
-        }]
+        labels: ["2016-05-27"],
+        datasets: [
+          {
+            xAxisID: "x",
+            data: [5],
+          },
+        ],
       },
       options: {
         scales: {
           x: {
             display: true,
-            type: 'time'
-          }
-        }
-      }
+            type: "time",
+          },
+        },
+      },
     });
 
     var xScale = chart.scales.x;
-    var pixel = xScale.getPixelForValue(moment('2016-05-27').valueOf());
+    var pixel = xScale.getPixelForValue(moment("2016-05-27").valueOf());
 
-    expect(xScale.getValueForPixel(pixel)).toEqual(moment(chart.data.labels[0]).valueOf());
+    expect(xScale.getValueForPixel(pixel)).toEqual(
+      moment(chart.data.labels[0]).valueOf()
+    );
   });
 
-  it('does not create a negative width chart when hidden', function() {
-    var chart = window.acquireChart({
-      type: 'line',
-      data: {
-        datasets: [{
-          data: []
-        }]
-      },
-      options: {
-        scales: {
-          x: {
-            type: 'time',
-            ticks: {
-              min: moment().subtract(1, 'months'),
-              max: moment(),
-            }
+  it("does not create a negative width chart when hidden", function () {
+    var chart = window.acquireChart(
+      {
+        type: "line",
+        data: {
+          datasets: [
+            {
+              data: [],
+            },
+          ],
+        },
+        options: {
+          scales: {
+            x: {
+              type: "time",
+              ticks: {
+                min: moment().subtract(1, "months"),
+                max: moment(),
+              },
+            },
           },
+          responsive: true,
         },
-        responsive: true,
       },
-    }, {
-      wrapper: {
-        style: 'display: none',
-      },
-    });
+      {
+        wrapper: {
+          style: "display: none",
+        },
+      }
+    );
     expect(chart.scales.y.width).toEqual(0);
     expect(chart.scales.y.maxWidth).toEqual(0);
     expect(chart.width).toEqual(0);
   });
 
-  describe('when ticks.source', function() {
-    describe('is "labels"', function() {
-      beforeEach(function() {
+  describe("when ticks.source", function () {
+    describe('is "labels"', function () {
+      beforeEach(function () {
         this.chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {
-            labels: ['2017', '2019', '2020', '2025', '2042'],
-            datasets: [{data: [0, 1, 2, 3, 4, 5]}]
+            labels: ["2017", "2019", "2020", "2025", "2042"],
+            datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
           },
           options: {
             scales: {
               x: {
-                type: 'time',
+                type: "time",
                 time: {
-                  parser: 'YYYY'
+                  parser: "YYYY",
                 },
                 ticks: {
-                  source: 'labels'
-                }
-              }
-            }
-          }
+                  source: "labels",
+                },
+              },
+            },
+          },
         });
       });
 
-      it ('should generate ticks from "data.labels"', function() {
+      it('should generate ticks from "data.labels"', function () {
         var scale = this.chart.scales.x;
 
-        expect(scale.min).toEqual(+moment('2017', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2042', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2017", "YYYY"));
+        expect(scale.max).toEqual(+moment("2042", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2019', '2020', '2025', '2042']);
+          "2017",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+        ]);
       });
-      it ('should not add ticks for min and max if they extend the labels range', function() {
+      it("should not add ticks for min and max if they extend the labels range", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.min = '2012';
-        options.max = '2051';
+        options.min = "2012";
+        options.max = "2051";
         chart.update();
 
-        expect(scale.min).toEqual(+moment('2012', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2051', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2012", "YYYY"));
+        expect(scale.max).toEqual(+moment("2051", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2019', '2020', '2025', '2042']);
+          "2017",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+        ]);
       });
-      it ('should not duplicate ticks if min and max are the labels limits', function() {
+      it("should not duplicate ticks if min and max are the labels limits", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.min = '2017';
-        options.max = '2042';
+        options.min = "2017";
+        options.max = "2042";
         chart.update();
 
-        expect(scale.min).toEqual(+moment('2017', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2042', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2017", "YYYY"));
+        expect(scale.max).toEqual(+moment("2042", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2019', '2020', '2025', '2042']);
+          "2017",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+        ]);
       });
-      it ('should correctly handle empty `data.labels` using "day" if `time.unit` is undefined`', function() {
+      it('should correctly handle empty `data.labels` using "day" if `time.unit` is undefined`', function () {
         var chart = this.chart;
         var scale = chart.scales.x;
 
         chart.data.labels = [];
         chart.update();
 
-        expect(scale.min).toEqual(+moment().startOf('day'));
-        expect(scale.max).toEqual(+moment().endOf('day') + 1);
+        expect(scale.min).toEqual(+moment().startOf("day"));
+        expect(scale.max).toEqual(+moment().endOf("day") + 1);
         expect(getLabels(scale)).toEqual([]);
       });
-      it ('should correctly handle empty `data.labels` using `time.unit`', function() {
+      it("should correctly handle empty `data.labels` using `time.unit`", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.time.unit = 'year';
+        options.time.unit = "year";
         chart.data.labels = [];
         chart.update();
 
-        expect(scale.min).toEqual(+moment().startOf('year'));
-        expect(scale.max).toEqual(+moment().endOf('year') + 1);
+        expect(scale.min).toEqual(+moment().startOf("year"));
+        expect(scale.max).toEqual(+moment().endOf("year") + 1);
         expect(getLabels(scale)).toEqual([]);
       });
     });
 
-    describe('is "data"', function() {
-      beforeEach(function() {
+    describe('is "data"', function () {
+      beforeEach(function () {
         this.chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {
-            labels: ['2017', '2019', '2020', '2025', '2042'],
+            labels: ["2017", "2019", "2020", "2025", "2042"],
             datasets: [
-              {data: [0, 1, 2, 3, 4, 5]},
-              {data: [
-                {x: '2018', y: 6},
-                {x: '2020', y: 7},
-                {x: '2043', y: 8}
-              ]}
-            ]
+              { data: [0, 1, 2, 3, 4, 5] },
+              {
+                data: [
+                  { x: "2018", y: 6 },
+                  { x: "2020", y: 7 },
+                  { x: "2043", y: 8 },
+                ],
+              },
+            ],
           },
           options: {
             scales: {
               x: {
-                type: 'time',
+                type: "time",
                 time: {
-                  parser: 'YYYY'
+                  parser: "YYYY",
                 },
                 ticks: {
-                  source: 'data'
-                }
-              }
-            }
-          }
+                  source: "data",
+                },
+              },
+            },
+          },
         });
       });
 
-      it ('should generate ticks from "datasets.data"', function() {
+      it('should generate ticks from "datasets.data"', function () {
         var scale = this.chart.scales.x;
 
-        expect(scale.min).toEqual(+moment('2017', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2043', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2017", "YYYY"));
+        expect(scale.max).toEqual(+moment("2043", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2018', '2019', '2020', '2025', '2042', '2043']);
+          "2017",
+          "2018",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+          "2043",
+        ]);
       });
-      it ('should not add ticks for min and max if they extend the labels range', function() {
+      it("should not add ticks for min and max if they extend the labels range", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.min = '2012';
-        options.max = '2051';
+        options.min = "2012";
+        options.max = "2051";
         chart.update();
 
-        expect(scale.min).toEqual(+moment('2012', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2051', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2012", "YYYY"));
+        expect(scale.max).toEqual(+moment("2051", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2018', '2019', '2020', '2025', '2042', '2043']);
+          "2017",
+          "2018",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+          "2043",
+        ]);
       });
-      it ('should not duplicate ticks if min and max are the labels limits', function() {
+      it("should not duplicate ticks if min and max are the labels limits", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.min = '2017';
-        options.max = '2043';
+        options.min = "2017";
+        options.max = "2043";
         chart.update();
 
-        expect(scale.min).toEqual(+moment('2017', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2043', 'YYYY'));
+        expect(scale.min).toEqual(+moment("2017", "YYYY"));
+        expect(scale.max).toEqual(+moment("2043", "YYYY"));
         expect(getLabels(scale)).toEqual([
-          '2017', '2018', '2019', '2020', '2025', '2042', '2043']);
+          "2017",
+          "2018",
+          "2019",
+          "2020",
+          "2025",
+          "2042",
+          "2043",
+        ]);
       });
-      it ('should correctly handle empty `data.labels` using "day" if `time.unit` is undefined`', function() {
+      it('should correctly handle empty `data.labels` using "day" if `time.unit` is undefined`', function () {
         var chart = this.chart;
         var scale = chart.scales.x;
 
         chart.data.labels = [];
         chart.update();
 
-        expect(scale.min).toEqual(+moment('2018', 'YYYY'));
-        expect(scale.max).toEqual(+moment('2043', 'YYYY'));
-        expect(getLabels(scale)).toEqual([
-          '2018', '2020', '2043']);
+        expect(scale.min).toEqual(+moment("2018", "YYYY"));
+        expect(scale.max).toEqual(+moment("2043", "YYYY"));
+        expect(getLabels(scale)).toEqual(["2018", "2020", "2043"]);
       });
-      it ('should correctly handle empty `data.labels` and hidden datasets using `time.unit`', function() {
+      it("should correctly handle empty `data.labels` and hidden datasets using `time.unit`", function () {
         var chart = this.chart;
         var scale = chart.scales.x;
         var options = chart.options.scales.x;
 
-        options.time.unit = 'year';
+        options.time.unit = "year";
         chart.data.labels = [];
         var meta = chart.getDatasetMeta(1);
         meta.hidden = true;
         chart.update();
 
-        expect(scale.min).toEqual(+moment().startOf('year'));
-        expect(scale.max).toEqual(+moment().endOf('year') + 1);
+        expect(scale.min).toEqual(+moment().startOf("year"));
+        expect(scale.max).toEqual(+moment().endOf("year") + 1);
         expect(getLabels(scale)).toEqual([]);
       });
     });
   });
 
-  [true, false].forEach(function(normalized) {
-    describe('when normalized is ' + normalized + ' and scale type', function() {
-      describe('is "timeseries"', function() {
-        beforeEach(function() {
-          this.chart = window.acquireChart({
-            type: 'line',
-            data: {
-              labels: ['2017', '2019', '2020', '2025', '2042'],
-              datasets: [{data: [0, 1, 2, 3, 4]}]
-            },
-            options: {
-              normalized,
-              scales: {
-                x: {
-                  type: 'timeseries',
-                  time: {
-                    parser: 'YYYY'
+  [true, false].forEach(function (normalized) {
+    describe(
+      "when normalized is " + normalized + " and scale type",
+      function () {
+        describe('is "timeseries"', function () {
+          beforeEach(function () {
+            this.chart = window.acquireChart({
+              type: "line",
+              data: {
+                labels: ["2017", "2019", "2020", "2025", "2042"],
+                datasets: [{ data: [0, 1, 2, 3, 4] }],
+              },
+              options: {
+                normalized,
+                scales: {
+                  x: {
+                    type: "timeseries",
+                    time: {
+                      parser: "YYYY",
+                    },
+                    ticks: {
+                      source: "labels",
+                    },
+                  },
+                  y: {
+                    display: false,
                   },
-                  ticks: {
-                    source: 'labels'
-                  }
                 },
-                y: {
-                  display: false
-                }
-              }
-            }
+              },
+            });
           });
-        });
-
-        it ('should space data out with the same gap, whatever their time values', function() {
-          var scale = this.chart.scales.x;
-          var start = scale.left;
-          var slice = scale.width / 4;
 
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 0)).toBeCloseToPixel(start);
-          expect(scale.getPixelForValue(moment('2019').valueOf(), 1)).toBeCloseToPixel(start + slice);
-          expect(scale.getPixelForValue(moment('2020').valueOf(), 2)).toBeCloseToPixel(start + slice * 2);
-          expect(scale.getPixelForValue(moment('2025').valueOf(), 3)).toBeCloseToPixel(start + slice * 3);
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 4)).toBeCloseToPixel(start + slice * 4);
-        });
-        it ('should add a step before if scale.min is before the first data', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
+          it("should space data out with the same gap, whatever their time values", function () {
+            var scale = this.chart.scales.x;
+            var start = scale.left;
+            var slice = scale.width / 4;
+
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 0)
+            ).toBeCloseToPixel(start);
+            expect(
+              scale.getPixelForValue(moment("2019").valueOf(), 1)
+            ).toBeCloseToPixel(start + slice);
+            expect(
+              scale.getPixelForValue(moment("2020").valueOf(), 2)
+            ).toBeCloseToPixel(start + slice * 2);
+            expect(
+              scale.getPixelForValue(moment("2025").valueOf(), 3)
+            ).toBeCloseToPixel(start + slice * 3);
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 4)
+            ).toBeCloseToPixel(start + slice * 4);
+          });
+          it("should add a step before if scale.min is before the first data", function () {
+            var chart = this.chart;
+            var scale = chart.scales.x;
+            var options = chart.options.scales.x;
 
-          options.min = '2012';
-          chart.update();
+            options.min = "2012";
+            chart.update();
 
-          var start = scale.left;
-          var slice = scale.width / 5;
+            var start = scale.left;
+            var slice = scale.width / 5;
 
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 1)).toBeCloseToPixel(86);
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 5)).toBeCloseToPixel(start + slice * 5);
-        });
-        it ('should add a step after if scale.max is after the last data', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 1)
+            ).toBeCloseToPixel(86);
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 5)
+            ).toBeCloseToPixel(start + slice * 5);
+          });
+          it("should add a step after if scale.max is after the last data", function () {
+            var chart = this.chart;
+            var scale = chart.scales.x;
+            var options = chart.options.scales.x;
 
-          options.max = '2050';
-          chart.update();
+            options.max = "2050";
+            chart.update();
 
-          var start = scale.left;
+            var start = scale.left;
 
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 0)).toBeCloseToPixel(start);
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 4)).toBeCloseToPixel(388);
-        });
-        it ('should add steps before and after if scale.min/max are outside the data range', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 0)
+            ).toBeCloseToPixel(start);
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 4)
+            ).toBeCloseToPixel(388);
+          });
+          it("should add steps before and after if scale.min/max are outside the data range", function () {
+            var chart = this.chart;
+            var scale = chart.scales.x;
+            var options = chart.options.scales.x;
 
-          options.min = '2012';
-          options.max = '2050';
-          chart.update();
+            options.min = "2012";
+            options.max = "2050";
+            chart.update();
 
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 1)).toBeCloseToPixel(71);
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 5)).toBeCloseToPixel(401);
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 1)
+            ).toBeCloseToPixel(71);
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 5)
+            ).toBeCloseToPixel(401);
+          });
         });
-      });
-      describe('is "time"', function() {
-        beforeEach(function() {
-          this.chart = window.acquireChart({
-            type: 'line',
-            data: {
-              labels: ['2017', '2019', '2020', '2025', '2042'],
-              datasets: [{data: [0, 1, 2, 3, 4, 5]}]
-            },
-            options: {
-              scales: {
-                x: {
-                  type: 'time',
-                  time: {
-                    parser: 'YYYY'
+        describe('is "time"', function () {
+          beforeEach(function () {
+            this.chart = window.acquireChart({
+              type: "line",
+              data: {
+                labels: ["2017", "2019", "2020", "2025", "2042"],
+                datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
+              },
+              options: {
+                scales: {
+                  x: {
+                    type: "time",
+                    time: {
+                      parser: "YYYY",
+                    },
+                    ticks: {
+                      source: "labels",
+                    },
+                  },
+                  y: {
+                    display: false,
                   },
-                  ticks: {
-                    source: 'labels'
-                  }
                 },
-                y: {
-                  display: false
-                }
-              }
-            }
+              },
+            });
           });
-        });
 
-        it ('should space data out with a gap relative to their time values', function() {
-          var scale = this.chart.scales.x;
-          var start = scale.left;
-          var slice = scale.width / (2042 - 2017);
+          it("should space data out with a gap relative to their time values", function () {
+            var scale = this.chart.scales.x;
+            var start = scale.left;
+            var slice = scale.width / (2042 - 2017);
+
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 0)
+            ).toBeCloseToPixel(start);
+            expect(
+              scale.getPixelForValue(moment("2019").valueOf(), 1)
+            ).toBeCloseToPixel(start + slice * (2019 - 2017));
+            expect(
+              scale.getPixelForValue(moment("2020").valueOf(), 2)
+            ).toBeCloseToPixel(start + slice * (2020 - 2017));
+            expect(
+              scale.getPixelForValue(moment("2025").valueOf(), 3)
+            ).toBeCloseToPixel(start + slice * (2025 - 2017));
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 4)
+            ).toBeCloseToPixel(start + slice * (2042 - 2017));
+          });
+          it("should take in account scale min and max if outside the ticks range", function () {
+            var chart = this.chart;
+            var scale = chart.scales.x;
+            var options = chart.options.scales.x;
 
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 0)).toBeCloseToPixel(start);
-          expect(scale.getPixelForValue(moment('2019').valueOf(), 1)).toBeCloseToPixel(start + slice * (2019 - 2017));
-          expect(scale.getPixelForValue(moment('2020').valueOf(), 2)).toBeCloseToPixel(start + slice * (2020 - 2017));
-          expect(scale.getPixelForValue(moment('2025').valueOf(), 3)).toBeCloseToPixel(start + slice * (2025 - 2017));
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 4)).toBeCloseToPixel(start + slice * (2042 - 2017));
-        });
-        it ('should take in account scale min and max if outside the ticks range', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
-
-          options.min = '2012';
-          options.max = '2050';
-          chart.update();
-
-          var start = scale.left;
-          var slice = scale.width / (2050 - 2012);
-
-          expect(scale.getPixelForValue(moment('2017').valueOf(), 0)).toBeCloseToPixel(start + slice * (2017 - 2012));
-          expect(scale.getPixelForValue(moment('2019').valueOf(), 1)).toBeCloseToPixel(start + slice * (2019 - 2012));
-          expect(scale.getPixelForValue(moment('2020').valueOf(), 2)).toBeCloseToPixel(start + slice * (2020 - 2012));
-          expect(scale.getPixelForValue(moment('2025').valueOf(), 3)).toBeCloseToPixel(start + slice * (2025 - 2012));
-          expect(scale.getPixelForValue(moment('2042').valueOf(), 4)).toBeCloseToPixel(start + slice * (2042 - 2012));
+            options.min = "2012";
+            options.max = "2050";
+            chart.update();
+
+            var start = scale.left;
+            var slice = scale.width / (2050 - 2012);
+
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf(), 0)
+            ).toBeCloseToPixel(start + slice * (2017 - 2012));
+            expect(
+              scale.getPixelForValue(moment("2019").valueOf(), 1)
+            ).toBeCloseToPixel(start + slice * (2019 - 2012));
+            expect(
+              scale.getPixelForValue(moment("2020").valueOf(), 2)
+            ).toBeCloseToPixel(start + slice * (2020 - 2012));
+            expect(
+              scale.getPixelForValue(moment("2025").valueOf(), 3)
+            ).toBeCloseToPixel(start + slice * (2025 - 2012));
+            expect(
+              scale.getPixelForValue(moment("2042").valueOf(), 4)
+            ).toBeCloseToPixel(start + slice * (2042 - 2012));
+          });
         });
-      });
-    });
+      }
+    );
   });
 
-  describe('when bounds', function() {
-    describe('is "data"', function() {
-      it ('should preserve the data range', function() {
+  describe("when bounds", function () {
+    describe('is "data"', function () {
+      it("should preserve the data range", function () {
         var chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {
-            labels: ['02/20 08:00', '02/21 09:00', '02/22 10:00', '02/23 11:00'],
-            datasets: [{data: [0, 1, 2, 3, 4, 5]}]
+            labels: [
+              "02/20 08:00",
+              "02/21 09:00",
+              "02/22 10:00",
+              "02/23 11:00",
+            ],
+            datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
           },
           options: {
             scales: {
               x: {
-                type: 'time',
-                bounds: 'data',
+                type: "time",
+                bounds: "data",
                 time: {
-                  parser: 'MM/DD HH:mm',
-                  unit: 'day'
-                }
+                  parser: "MM/DD HH:mm",
+                  unit: "day",
+                },
               },
               y: {
-                display: false
-              }
-            }
-          }
+                display: false,
+              },
+            },
+          },
         });
 
         var scale = chart.scales.x;
 
-        expect(scale.min).toEqual(+moment('02/20 08:00', 'MM/DD HH:mm'));
-        expect(scale.max).toEqual(+moment('02/23 11:00', 'MM/DD HH:mm'));
-        expect(scale.getPixelForValue(moment('02/20 08:00', 'MM/DD HH:mm').valueOf())).toBeCloseToPixel(scale.left);
-        expect(scale.getPixelForValue(moment('02/23 11:00', 'MM/DD HH:mm').valueOf())).toBeCloseToPixel(scale.left + scale.width);
-        expect(getLabels(scale)).toEqual([
-          'Feb 21', 'Feb 22', 'Feb 23']);
+        expect(scale.min).toEqual(+moment("02/20 08:00", "MM/DD HH:mm"));
+        expect(scale.max).toEqual(+moment("02/23 11:00", "MM/DD HH:mm"));
+        expect(
+          scale.getPixelForValue(moment("02/20 08:00", "MM/DD HH:mm").valueOf())
+        ).toBeCloseToPixel(scale.left);
+        expect(
+          scale.getPixelForValue(moment("02/23 11:00", "MM/DD HH:mm").valueOf())
+        ).toBeCloseToPixel(scale.left + scale.width);
+        expect(getLabels(scale)).toEqual(["Feb 21", "Feb 22", "Feb 23"]);
       });
     });
 
-    describe('is "labels"', function() {
-      it('should preserve the label range', function() {
+    describe('is "labels"', function () {
+      it("should preserve the label range", function () {
         var chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {
-            labels: ['02/20 08:00', '02/21 09:00', '02/22 10:00', '02/23 11:00'],
-            datasets: [{data: [0, 1, 2, 3, 4, 5]}]
+            labels: [
+              "02/20 08:00",
+              "02/21 09:00",
+              "02/22 10:00",
+              "02/23 11:00",
+            ],
+            datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
           },
           options: {
             scales: {
               x: {
-                type: 'time',
-                bounds: 'ticks',
+                type: "time",
+                bounds: "ticks",
                 time: {
-                  parser: 'MM/DD HH:mm',
-                  unit: 'day'
-                }
+                  parser: "MM/DD HH:mm",
+                  unit: "day",
+                },
               },
               y: {
-                display: false
-              }
-            }
-          }
+                display: false,
+              },
+            },
+          },
         });
 
         var scale = chart.scales.x;
@@ -923,311 +1108,458 @@ describe('Time scale tests', function() {
 
         expect(scale.min).toEqual(ticks[0].value);
         expect(scale.max).toEqual(ticks[ticks.length - 1].value);
-        expect(scale.getPixelForValue(moment('02/20 08:00', 'MM/DD HH:mm').valueOf())).toBeCloseToPixel(60);
-        expect(scale.getPixelForValue(moment('02/23 11:00', 'MM/DD HH:mm').valueOf())).toBeCloseToPixel(426);
+        expect(
+          scale.getPixelForValue(moment("02/20 08:00", "MM/DD HH:mm").valueOf())
+        ).toBeCloseToPixel(60);
+        expect(
+          scale.getPixelForValue(moment("02/23 11:00", "MM/DD HH:mm").valueOf())
+        ).toBeCloseToPixel(426);
         expect(getLabels(scale)).toEqual([
-          'Feb 20', 'Feb 21', 'Feb 22', 'Feb 23', 'Feb 24']);
+          "Feb 20",
+          "Feb 21",
+          "Feb 22",
+          "Feb 23",
+          "Feb 24",
+        ]);
+      });
+    });
+  });
+
+  describe("when min and/or max are defined", function () {
+    ["auto", "data", "labels"].forEach(function (source) {
+      ["data", "ticks"].forEach(function (bounds) {
+        describe(
+          'and ticks.source is "' + source + '" and bounds "' + bounds + '"',
+          function () {
+            beforeEach(function () {
+              this.chart = window.acquireChart({
+                type: "line",
+                data: {
+                  labels: [
+                    "02/20 08:00",
+                    "02/21 09:00",
+                    "02/22 10:00",
+                    "02/23 11:00",
+                  ],
+                  datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
+                },
+                options: {
+                  scales: {
+                    x: {
+                      type: "time",
+                      bounds: bounds,
+                      time: {
+                        parser: "MM/DD HH:mm",
+                        unit: "day",
+                      },
+                      ticks: {
+                        source: source,
+                      },
+                    },
+                    y: {
+                      display: false,
+                    },
+                  },
+                },
+              });
+            });
+
+            it("should expand scale to the min/max range", function () {
+              var chart = this.chart;
+              var scale = chart.scales.x;
+              var options = chart.options.scales.x;
+              var min = "02/19 07:00";
+              var max = "02/24 08:00";
+              var minMillis = +moment(min, "MM/DD HH:mm");
+              var maxMillis = +moment(max, "MM/DD HH:mm");
+
+              options.min = min;
+              options.max = max;
+              chart.update();
+
+              expect(scale.min).toEqual(minMillis);
+              expect(scale.max).toEqual(maxMillis);
+              expect(scale.getPixelForValue(minMillis)).toBeCloseToPixel(
+                scale.left
+              );
+              expect(scale.getPixelForValue(maxMillis)).toBeCloseToPixel(
+                scale.left + scale.width
+              );
+              scale.getTicks().forEach(function (tick) {
+                expect(tick.value >= minMillis).toBeTruthy();
+                expect(tick.value <= maxMillis).toBeTruthy();
+              });
+            });
+            it("should shrink scale to the min/max range", function () {
+              var chart = this.chart;
+              var scale = chart.scales.x;
+              var options = chart.options.scales.x;
+              var min = "02/21 07:00";
+              var max = "02/22 20:00";
+              var minMillis = +moment(min, "MM/DD HH:mm");
+              var maxMillis = +moment(max, "MM/DD HH:mm");
+
+              options.min = min;
+              options.max = max;
+              chart.update();
+
+              expect(scale.min).toEqual(minMillis);
+              expect(scale.max).toEqual(maxMillis);
+              expect(scale.getPixelForValue(minMillis)).toBeCloseToPixel(
+                scale.left
+              );
+              expect(scale.getPixelForValue(maxMillis)).toBeCloseToPixel(
+                scale.left + scale.width
+              );
+              scale.getTicks().forEach(function (tick) {
+                expect(tick.value >= minMillis).toBeTruthy();
+                expect(tick.value <= maxMillis).toBeTruthy();
+              });
+            });
+          }
+        );
       });
     });
   });
 
-  describe('when min and/or max are defined', function() {
-    ['auto', 'data', 'labels'].forEach(function(source) {
-      ['data', 'ticks'].forEach(function(bounds) {
-        describe('and ticks.source is "' + source + '" and bounds "' + bounds + '"', function() {
-          beforeEach(function() {
+  ["auto", "data", "labels"].forEach(function (source) {
+    ["timeseries", "time"].forEach(function (type) {
+      describe(
+        'when ticks.source is "' +
+          source +
+          '" and scale type is "' +
+          type +
+          '"',
+        function () {
+          beforeEach(function () {
             this.chart = window.acquireChart({
-              type: 'line',
+              type: "line",
               data: {
-                labels: ['02/20 08:00', '02/21 09:00', '02/22 10:00', '02/23 11:00'],
-                datasets: [{data: [0, 1, 2, 3, 4, 5]}]
+                labels: ["2017", "2018", "2019", "2020", "2021"],
+                datasets: [{ data: [0, 1, 2, 3, 4] }],
               },
               options: {
                 scales: {
                   x: {
-                    type: 'time',
-                    bounds: bounds,
+                    type: type,
                     time: {
-                      parser: 'MM/DD HH:mm',
-                      unit: 'day'
+                      parser: "YYYY",
+                      unit: "year",
                     },
                     ticks: {
-                      source: source
-                    }
+                      source: source,
+                    },
                   },
-                  y: {
-                    display: false
-                  }
-                }
-              }
+                },
+              },
             });
           });
 
-          it ('should expand scale to the min/max range', function() {
+          it("should not add offset from the edges", function () {
+            var scale = this.chart.scales.x;
+
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf())
+            ).toBeCloseToPixel(scale.left);
+            expect(
+              scale.getPixelForValue(moment("2021").valueOf())
+            ).toBeCloseToPixel(scale.left + scale.width);
+          });
+
+          it("should add offset from the edges if offset is true", function () {
             var chart = this.chart;
             var scale = chart.scales.x;
             var options = chart.options.scales.x;
-            var min = '02/19 07:00';
-            var max = '02/24 08:00';
-            var minMillis = +moment(min, 'MM/DD HH:mm');
-            var maxMillis = +moment(max, 'MM/DD HH:mm');
 
-            options.min = min;
-            options.max = max;
+            options.offset = true;
             chart.update();
 
-            expect(scale.min).toEqual(minMillis);
-            expect(scale.max).toEqual(maxMillis);
-            expect(scale.getPixelForValue(minMillis)).toBeCloseToPixel(scale.left);
-            expect(scale.getPixelForValue(maxMillis)).toBeCloseToPixel(scale.left + scale.width);
-            scale.getTicks().forEach(function(tick) {
-              expect(tick.value >= minMillis).toBeTruthy();
-              expect(tick.value <= maxMillis).toBeTruthy();
-            });
+            var numTicks = scale.ticks.length;
+            var firstTickInterval =
+              scale.getPixelForTick(1) - scale.getPixelForTick(0);
+            var lastTickInterval =
+              scale.getPixelForTick(numTicks - 1) -
+              scale.getPixelForTick(numTicks - 2);
+
+            expect(
+              scale.getPixelForValue(moment("2017").valueOf())
+            ).toBeCloseToPixel(scale.left + firstTickInterval / 2);
+            expect(
+              scale.getPixelForValue(moment("2021").valueOf())
+            ).toBeCloseToPixel(scale.left + scale.width - lastTickInterval / 2);
           });
-          it ('should shrink scale to the min/max range', function() {
+
+          it("should not add offset if min and max extend the labels range", function () {
             var chart = this.chart;
             var scale = chart.scales.x;
             var options = chart.options.scales.x;
-            var min = '02/21 07:00';
-            var max = '02/22 20:00';
-            var minMillis = +moment(min, 'MM/DD HH:mm');
-            var maxMillis = +moment(max, 'MM/DD HH:mm');
 
-            options.min = min;
-            options.max = max;
+            options.min = "2012";
+            options.max = "2051";
             chart.update();
 
-            expect(scale.min).toEqual(minMillis);
-            expect(scale.max).toEqual(maxMillis);
-            expect(scale.getPixelForValue(minMillis)).toBeCloseToPixel(scale.left);
-            expect(scale.getPixelForValue(maxMillis)).toBeCloseToPixel(scale.left + scale.width);
-            scale.getTicks().forEach(function(tick) {
-              expect(tick.value >= minMillis).toBeTruthy();
-              expect(tick.value <= maxMillis).toBeTruthy();
-            });
-          });
-        });
-      });
-    });
-  });
-
-  ['auto', 'data', 'labels'].forEach(function(source) {
-    ['timeseries', 'time'].forEach(function(type) {
-      describe('when ticks.source is "' + source + '" and scale type is "' + type + '"', function() {
-        beforeEach(function() {
-          this.chart = window.acquireChart({
-            type: 'line',
-            data: {
-              labels: ['2017', '2018', '2019', '2020', '2021'],
-              datasets: [{data: [0, 1, 2, 3, 4]}]
-            },
-            options: {
-              scales: {
-                x: {
-                  type: type,
-                  time: {
-                    parser: 'YYYY',
-                    unit: 'year'
-                  },
-                  ticks: {
-                    source: source
-                  }
-                }
-              }
-            }
+            expect(
+              scale.getPixelForValue(moment("2012").valueOf())
+            ).toBeCloseToPixel(scale.left);
+            expect(
+              scale.getPixelForValue(moment("2051").valueOf())
+            ).toBeCloseToPixel(scale.left + scale.width);
           });
-        });
-
-        it ('should not add offset from the edges', function() {
-          var scale = this.chart.scales.x;
-
-          expect(scale.getPixelForValue(moment('2017').valueOf())).toBeCloseToPixel(scale.left);
-          expect(scale.getPixelForValue(moment('2021').valueOf())).toBeCloseToPixel(scale.left + scale.width);
-        });
-
-        it ('should add offset from the edges if offset is true', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
-
-          options.offset = true;
-          chart.update();
-
-          var numTicks = scale.ticks.length;
-          var firstTickInterval = scale.getPixelForTick(1) - scale.getPixelForTick(0);
-          var lastTickInterval = scale.getPixelForTick(numTicks - 1) - scale.getPixelForTick(numTicks - 2);
-
-          expect(scale.getPixelForValue(moment('2017').valueOf())).toBeCloseToPixel(scale.left + firstTickInterval / 2);
-          expect(scale.getPixelForValue(moment('2021').valueOf())).toBeCloseToPixel(scale.left + scale.width - lastTickInterval / 2);
-        });
-
-        it ('should not add offset if min and max extend the labels range', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
-
-          options.min = '2012';
-          options.max = '2051';
-          chart.update();
-
-          expect(scale.getPixelForValue(moment('2012').valueOf())).toBeCloseToPixel(scale.left);
-          expect(scale.getPixelForValue(moment('2051').valueOf())).toBeCloseToPixel(scale.left + scale.width);
-        });
-      });
+        }
+      );
     });
   });
 
-  it ('should handle offset when there are more data points than ticks', function() {
+  it("should handle offset when there are more data points than ticks", function () {
     const chart = window.acquireChart({
-      type: 'bar',
+      type: "bar",
       data: {
-        datasets: [{
-          data: [{x: 631180800000, y: '31.84'}, {x: 631267200000, y: '30.89'}, {x: 631353600000, y: '33.00'}, {x: 631440000000, y: '33.52'}, {x: 631526400000, y: '32.24'}, {x: 631785600000, y: '32.74'}, {x: 631872000000, y: '31.45'}, {x: 631958400000, y: '32.60'}, {x: 632044800000, y: '31.77'}, {x: 632131200000, y: '32.45'}, {x: 632390400000, y: '31.13'}, {x: 632476800000, y: '31.82'}, {x: 632563200000, y: '30.81'}, {x: 632649600000, y: '30.07'}, {x: 632736000000, y: '29.31'}, {x: 632995200000, y: '29.82'}, {x: 633081600000, y: '30.20'}, {x: 633168000000, y: '30.78'}, {x: 633254400000, y: '30.72'}, {x: 633340800000, y: '31.62'}, {x: 633600000000, y: '30.64'}, {x: 633686400000, y: '32.36'}, {x: 633772800000, y: '34.66'}, {x: 633859200000, y: '33.96'}, {x: 633945600000, y: '34.20'}, {x: 634204800000, y: '32.20'}, {x: 634291200000, y: '32.44'}, {x: 634377600000, y: '32.72'}, {x: 634464000000, y: '32.95'}, {x: 634550400000, y: '32.95'}, {x: 634809600000, y: '30.88'}, {x: 634896000000, y: '29.44'}, {x: 634982400000, y: '29.36'}, {x: 635068800000, y: '28.84'}, {x: 635155200000, y: '30.85'}, {x: 635414400000, y: '32.00'}, {x: 635500800000, y: '32.74'}, {x: 635587200000, y: '33.16'}, {x: 635673600000, y: '34.73'}, {x: 635760000000, y: '32.89'}, {x: 636019200000, y: '32.41'}, {x: 636105600000, y: '31.15'}, {x: 636192000000, y: '30.63'}, {x: 636278400000, y: '29.60'}, {x: 636364800000, y: '29.31'}, {x: 636624000000, y: '29.83'}, {x: 636710400000, y: '27.97'}, {x: 636796800000, y: '26.18'}, {x: 636883200000, y: '26.06'}, {x: 636969600000, y: '26.34'}, {x: 637228800000, y: '27.75'}, {x: 637315200000, y: '29.05'}, {x: 637401600000, y: '28.82'}, {x: 637488000000, y: '29.43'}, {x: 637574400000, y: '29.53'}, {x: 637833600000, y: '28.50'}, {x: 637920000000, y: '28.87'}, {x: 638006400000, y: '28.11'}, {x: 638092800000, y: '27.79'}, {x: 638179200000, y: '28.18'}, {x: 638438400000, y: '28.27'}, {x: 638524800000, y: '28.29'}, {x: 638611200000, y: '29.63'}, {x: 638697600000, y: '29.13'}, {x: 638784000000, y: '26.57'}, {x: 639039600000, y: '27.19'}, {x: 639126000000, y: '27.48'}, {x: 639212400000, y: '27.79'}, {x: 639298800000, y: '28.48'}, {x: 639385200000, y: '27.88'}, {x: 639644400000, y: '25.63'}, {x: 639730800000, y: '25.02'}, {x: 639817200000, y: '25.26'}, {x: 639903600000, y: '25.00'}, {x: 639990000000, y: '26.23'}, {x: 640249200000, y: '26.22'}, {x: 640335600000, y: '26.36'}, {x: 640422000000, y: '25.45'}, {x: 640508400000, y: '24.62'}, {x: 640594800000, y: '26.65'}, {x: 640854000000, y: '26.28'}, {x: 640940400000, y: '27.25'}, {x: 641026800000, y: '25.93'}],
-          backgroundColor: '#ff6666'
-        }]
+        datasets: [
+          {
+            data: [
+              { x: 631180800000, y: "31.84" },
+              { x: 631267200000, y: "30.89" },
+              { x: 631353600000, y: "33.00" },
+              { x: 631440000000, y: "33.52" },
+              { x: 631526400000, y: "32.24" },
+              { x: 631785600000, y: "32.74" },
+              { x: 631872000000, y: "31.45" },
+              { x: 631958400000, y: "32.60" },
+              { x: 632044800000, y: "31.77" },
+              { x: 632131200000, y: "32.45" },
+              { x: 632390400000, y: "31.13" },
+              { x: 632476800000, y: "31.82" },
+              { x: 632563200000, y: "30.81" },
+              { x: 632649600000, y: "30.07" },
+              { x: 632736000000, y: "29.31" },
+              { x: 632995200000, y: "29.82" },
+              { x: 633081600000, y: "30.20" },
+              { x: 633168000000, y: "30.78" },
+              { x: 633254400000, y: "30.72" },
+              { x: 633340800000, y: "31.62" },
+              { x: 633600000000, y: "30.64" },
+              { x: 633686400000, y: "32.36" },
+              { x: 633772800000, y: "34.66" },
+              { x: 633859200000, y: "33.96" },
+              { x: 633945600000, y: "34.20" },
+              { x: 634204800000, y: "32.20" },
+              { x: 634291200000, y: "32.44" },
+              { x: 634377600000, y: "32.72" },
+              { x: 634464000000, y: "32.95" },
+              { x: 634550400000, y: "32.95" },
+              { x: 634809600000, y: "30.88" },
+              { x: 634896000000, y: "29.44" },
+              { x: 634982400000, y: "29.36" },
+              { x: 635068800000, y: "28.84" },
+              { x: 635155200000, y: "30.85" },
+              { x: 635414400000, y: "32.00" },
+              { x: 635500800000, y: "32.74" },
+              { x: 635587200000, y: "33.16" },
+              { x: 635673600000, y: "34.73" },
+              { x: 635760000000, y: "32.89" },
+              { x: 636019200000, y: "32.41" },
+              { x: 636105600000, y: "31.15" },
+              { x: 636192000000, y: "30.63" },
+              { x: 636278400000, y: "29.60" },
+              { x: 636364800000, y: "29.31" },
+              { x: 636624000000, y: "29.83" },
+              { x: 636710400000, y: "27.97" },
+              { x: 636796800000, y: "26.18" },
+              { x: 636883200000, y: "26.06" },
+              { x: 636969600000, y: "26.34" },
+              { x: 637228800000, y: "27.75" },
+              { x: 637315200000, y: "29.05" },
+              { x: 637401600000, y: "28.82" },
+              { x: 637488000000, y: "29.43" },
+              { x: 637574400000, y: "29.53" },
+              { x: 637833600000, y: "28.50" },
+              { x: 637920000000, y: "28.87" },
+              { x: 638006400000, y: "28.11" },
+              { x: 638092800000, y: "27.79" },
+              { x: 638179200000, y: "28.18" },
+              { x: 638438400000, y: "28.27" },
+              { x: 638524800000, y: "28.29" },
+              { x: 638611200000, y: "29.63" },
+              { x: 638697600000, y: "29.13" },
+              { x: 638784000000, y: "26.57" },
+              { x: 639039600000, y: "27.19" },
+              { x: 639126000000, y: "27.48" },
+              { x: 639212400000, y: "27.79" },
+              { x: 639298800000, y: "28.48" },
+              { x: 639385200000, y: "27.88" },
+              { x: 639644400000, y: "25.63" },
+              { x: 639730800000, y: "25.02" },
+              { x: 639817200000, y: "25.26" },
+              { x: 639903600000, y: "25.00" },
+              { x: 639990000000, y: "26.23" },
+              { x: 640249200000, y: "26.22" },
+              { x: 640335600000, y: "26.36" },
+              { x: 640422000000, y: "25.45" },
+              { x: 640508400000, y: "24.62" },
+              { x: 640594800000, y: "26.65" },
+              { x: 640854000000, y: "26.28" },
+              { x: 640940400000, y: "27.25" },
+              { x: 641026800000, y: "25.93" },
+            ],
+            backgroundColor: "#ff6666",
+          },
+        ],
       },
       options: {
         scales: {
           x: {
-            type: 'timeseries',
+            type: "timeseries",
             offset: true,
             ticks: {
-              source: 'data',
+              source: "data",
               autoSkip: true,
               autoSkipPadding: 0,
-              maxRotation: 0
-            }
+              maxRotation: 0,
+            },
           },
           y: {
-            type: 'linear',
+            type: "linear",
             grid: {
-              drawBorder: false
-            }
-          }
-        }
+              drawBorder: false,
+            },
+          },
+        },
       },
       plugins: {
-        legend: false
-      }
+        legend: false,
+      },
     });
     const scale = chart.scales.x;
     expect(scale.getPixelForDecimal(0)).toBeCloseToPixel(29);
     expect(scale.getPixelForDecimal(1.0)).toBeCloseToPixel(512);
   });
 
-  ['data', 'labels'].forEach(function(source) {
-    ['timeseries', 'time'].forEach(function(type) {
-      describe('when ticks.source is "' + source + '" and scale type is "' + type + '"', function() {
-        beforeEach(function() {
-          this.chart = window.acquireChart({
-            type: 'line',
-            data: {
-              labels: ['2017', '2019', '2020', '2025', '2042'],
-              datasets: [{data: [0, 1, 2, 3, 4, 5]}]
-            },
-            options: {
-              scales: {
-                x: {
-                  id: 'x',
-                  type: type,
-                  time: {
-                    parser: 'YYYY'
+  ["data", "labels"].forEach(function (source) {
+    ["timeseries", "time"].forEach(function (type) {
+      describe(
+        'when ticks.source is "' +
+          source +
+          '" and scale type is "' +
+          type +
+          '"',
+        function () {
+          beforeEach(function () {
+            this.chart = window.acquireChart({
+              type: "line",
+              data: {
+                labels: ["2017", "2019", "2020", "2025", "2042"],
+                datasets: [{ data: [0, 1, 2, 3, 4, 5] }],
+              },
+              options: {
+                scales: {
+                  x: {
+                    id: "x",
+                    type: type,
+                    time: {
+                      parser: "YYYY",
+                    },
+                    ticks: {
+                      source: source,
+                    },
                   },
-                  ticks: {
-                    source: source
-                  }
-                }
-              }
-            }
+                },
+              },
+            });
           });
-        });
 
-        it ('should add offset if min and max extend the labels range and offset is true', function() {
-          var chart = this.chart;
-          var scale = chart.scales.x;
-          var options = chart.options.scales.x;
-
-          options.min = '2012';
-          options.max = '2051';
-          options.offset = true;
-          chart.update();
-
-          var numTicks = scale.ticks.length;
-          var firstTickInterval = scale.getPixelForTick(1) - scale.getPixelForTick(0);
-          var lastTickInterval = scale.getPixelForTick(numTicks - 1) - scale.getPixelForTick(numTicks - 2);
-          expect(scale.getPixelForValue(moment('2012').valueOf())).toBeCloseToPixel(scale.left + firstTickInterval / 2);
-          expect(scale.getPixelForValue(moment('2051').valueOf())).toBeCloseToPixel(scale.left + scale.width - lastTickInterval / 2);
-        });
-      });
+          it("should add offset if min and max extend the labels range and offset is true", function () {
+            var chart = this.chart;
+            var scale = chart.scales.x;
+            var options = chart.options.scales.x;
+
+            options.min = "2012";
+            options.max = "2051";
+            options.offset = true;
+            chart.update();
+
+            var numTicks = scale.ticks.length;
+            var firstTickInterval =
+              scale.getPixelForTick(1) - scale.getPixelForTick(0);
+            var lastTickInterval =
+              scale.getPixelForTick(numTicks - 1) -
+              scale.getPixelForTick(numTicks - 2);
+            expect(
+              scale.getPixelForValue(moment("2012").valueOf())
+            ).toBeCloseToPixel(scale.left + firstTickInterval / 2);
+            expect(
+              scale.getPixelForValue(moment("2051").valueOf())
+            ).toBeCloseToPixel(scale.left + scale.width - lastTickInterval / 2);
+          });
+        }
+      );
     });
   });
 
-  describe('Deprecations', function() {
-    describe('options.time.displayFormats', function() {
-      it('should generate defaults from adapter presets', function() {
+  describe("Deprecations", function () {
+    describe("options.time.displayFormats", function () {
+      it("should generate defaults from adapter presets", function () {
         var chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {},
           options: {
             scales: {
               x: {
-                type: 'time'
-              }
-            }
-          }
+                type: "time",
+              },
+            },
+          },
         });
 
         // NOTE: the test suite is configured to use moment
         var expected = {
-          datetime: 'MMM D, YYYY, h:mm:ss a',
-          millisecond: 'h:mm:ss.SSS a',
-          second: 'h:mm:ss a',
-          minute: 'h:mm a',
-          hour: 'hA',
-          day: 'MMM D',
-          week: 'll',
-          month: 'MMM YYYY',
-          quarter: '[Q]Q - YYYY',
-          year: 'YYYY'
+          datetime: "MMM D, YYYY, h:mm:ss a",
+          millisecond: "h:mm:ss.SSS a",
+          second: "h:mm:ss a",
+          minute: "h:mm a",
+          hour: "hA",
+          day: "MMM D",
+          week: "ll",
+          month: "MMM YYYY",
+          quarter: "[Q]Q - YYYY",
+          year: "YYYY",
         };
 
         expect(chart.scales.x.options.time.displayFormats).toEqual(expected);
         expect(chart.options.scales.x.time.displayFormats).toEqual(expected);
       });
 
-      it('should merge user formats with adapter presets', function() {
+      it("should merge user formats with adapter presets", function () {
         var chart = window.acquireChart({
-          type: 'line',
+          type: "line",
           data: {},
           options: {
             scales: {
               x: {
-                type: 'time',
+                type: "time",
                 time: {
                   displayFormats: {
-                    millisecond: 'foo',
-                    hour: 'bar',
-                    month: 'bla'
-                  }
-                }
-              }
-            }
-          }
+                    millisecond: "foo",
+                    hour: "bar",
+                    month: "bla",
+                  },
+                },
+              },
+            },
+          },
         });
 
         // NOTE: the test suite is configured to use moment
         var expected = {
-          datetime: 'MMM D, YYYY, h:mm:ss a',
-          millisecond: 'foo',
-          second: 'h:mm:ss a',
-          minute: 'h:mm a',
-          hour: 'bar',
-          day: 'MMM D',
-          week: 'll',
-          month: 'bla',
-          quarter: '[Q]Q - YYYY',
-          year: 'YYYY'
+          datetime: "MMM D, YYYY, h:mm:ss a",
+          millisecond: "foo",
+          second: "h:mm:ss a",
+          minute: "h:mm a",
+          hour: "bar",
+          day: "MMM D",
+          week: "ll",
+          month: "bla",
+          quarter: "[Q]Q - YYYY",
+          year: "YYYY",
         };
 
         expect(chart.scales.x.options.time.displayFormats).toEqual(expected);
@@ -1235,4 +1567,35 @@ describe('Time scale tests', function() {
       });
     });
   });
+
+  it("should respect min/max options specified as numbers", function () {
+    const minTimestamp = 1640995200000; // Jan 1, 2022
+    const maxTimestamp = 1641081600000; // Jan 2, 2022
+
+    const chart = acquireChart({
+      type: "line",
+      data: {
+        datasets: [
+          {
+            data: [
+              { x: minTimestamp - 1000, y: 10 },
+              { x: maxTimestamp + 1000, y: 20 },
+            ],
+          },
+        ],
+      },
+      options: {
+        scales: {
+          x: {
+            type: "time",
+            min: minTimestamp,
+            max: maxTimestamp,
+          },
+        },
+      },
+    });
+
+    expect(chart.scales.x.min).toEqual(minTimestamp);
+    expect(chart.scales.x.max).toEqual(maxTimestamp);
+  });
 });
